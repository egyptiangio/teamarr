{% extends "base.html" %}

{% block title %}{% if mode == 'add' %}Add{% else %}Edit{% endif %} Event Group - Teamarr{% endblock %}

{% block content %}
<div class="form-container">
    <div class="page-header">
        <div style="margin-bottom: 0.75rem;">
            {% if mode == 'add' %}
            <a href="{{ url_for('event_groups_import') }}" class="btn btn-sm btn-secondary">&larr; Back to Import</a>
            {% else %}
            <a href="{{ url_for('event_groups_list') }}" class="btn btn-sm btn-secondary">&larr; Back to Event Groups</a>
            {% endif %}
        </div>
        <h1>{% if mode == 'add' %}Add Event Group{% else %}Edit Event Group{% endif %}</h1>
        {% if mode == 'edit' %}
            <p class="page-subtitle">{{ group.group_name }}</p>
        {% endif %}
    </div>

    <form id="event-group-form" method="POST">
        <!-- Group Info Section -->
        <div class="form-section">
            {% if mode == 'edit' %}
                <!-- Read-only group info for edit mode -->
                <div class="group-info-display">
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <div style="background: var(--primary); color: white; width: 48px; height: 48px; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-weight: 600;">
                            {{ group.assigned_league[:3].upper() }}
                        </div>
                        <div>
                            <h3 style="margin: 0;">{{ group.group_name }}</h3>
                            <p class="text-muted" style="margin: 0.25rem 0 0 0;">
                                {{ group.assigned_sport | title }} &bull; {{ group.assigned_league.upper() }}
                                {% if group.account_name %}&bull; {{ group.account_name }}{% endif %}
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Hidden fields for edit mode -->
                <input type="hidden" name="group_id" value="{{ group.id }}">
            {% else %}
                <!-- Add mode: sport/league selection -->
                <input type="hidden" name="dispatcharr_group_id" value="{{ dispatcharr_group_id }}">
                <input type="hidden" name="dispatcharr_account_id" value="{{ dispatcharr_account_id }}">
                <input type="hidden" name="group_name" value="{{ group_name }}">
                <input type="hidden" name="account_name" value="{{ account_name }}">

                <div class="group-info-display">
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <div style="background: var(--bg-tertiary); border: 2px dashed var(--border); width: 48px; height: 48px; border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                            <span style="color: var(--text-muted);">?</span>
                        </div>
                        <div>
                            <h3 style="margin: 0;">{{ group_name }}</h3>
                            <p class="text-muted" style="margin: 0.25rem 0 0 0;">
                                {% if account_name %}{{ account_name }}{% else %}New event group{% endif %}
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Hidden field for multi-sport mode -->
                <input type="hidden" id="is_multi_sport" name="is_multi_sport" value="0">

                <!-- Group Type Selection (immutable after accept) -->
                <div id="group-type-selector" class="group-type-selector">
                    <label class="form-label">Group Type <span class="required">*</span></label>
                    <div class="group-type-options">
                        <label class="group-type-option">
                            <input type="radio" name="group_type_choice" value="single" checked>
                            <div class="option-content">
                                <strong>Single League</strong>
                                <span>Match streams to events in one specific league (e.g., NFL, NBA, EPL)</span>
                            </div>
                        </label>
                        <label class="group-type-option">
                            <input type="radio" name="group_type_choice" value="multi">
                            <div class="option-content">
                                <strong>Multi-Sport / Multi-League</strong>
                                <span>Match streams across multiple sports and leagues (e.g., ESPN+)</span>
                            </div>
                        </label>
                    </div>
                    <button type="button" id="accept-group-type" class="btn btn-primary" style="margin-top: 1rem;" onclick="acceptGroupType()">
                        Continue
                    </button>
                </div>

                <!-- Locked indicator (shown after type accepted) -->
                <div id="group-type-locked" class="group-type-locked" style="display: none;">
                    <div class="locked-badge">
                        <span class="lock-icon">ðŸ”’</span>
                        <span id="locked-type-label">Single League</span>
                    </div>
                </div>

                <!-- Single League Settings (shown after accepting single league type) -->
                <div id="single-league-settings" style="display: none;">
                    <!-- Parent Group Selection -->
                    <div class="form-group" style="margin-top: 1rem;">
                        <label for="parent_group_id">Group Hierarchy</label>
                        <select id="parent_group_id" name="parent_group_id" class="form-control" onchange="handleParentGroupChange()">
                            <option value="">Independent Group (creates its own channels)</option>
                        </select>
                        <small class="form-help">Child groups add streams to their parent's channels instead of creating new ones.</small>
                    </div>

                    <!-- Child Group Notice - shown when parent selected -->
                    <div id="child-group-notice" class="child-group-notice" style="display: none;">
                        <div class="notice-icon">â†³</div>
                        <div class="notice-content">
                            <strong>Child Group Mode</strong>
                            <p>This group will add its matched streams to the parent group's channels. Sport, league, template and channel settings are inherited from the parent. Custom regex settings remain available to match your provider's stream names.</p>
                        </div>
                    </div>

                    <div class="form-row" id="sport-league-row">
                        <div class="form-group">
                            <label for="assigned_sport">Sport <span class="required" id="sport-required">*</span></label>
                            <select id="assigned_sport" name="assigned_sport" class="form-control" onchange="updateLeagueOptions()" required>
                                <option value="">Loading sports...</option>
                            </select>
                        </div>

                        <div class="form-group" id="league-group">
                            <label for="assigned_league">League <span class="required" id="league-required">*</span></label>
                            <select id="assigned_league" name="assigned_league" class="form-control" required>
                                <option value="">Select sport first...</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Multi-Sport Settings (shown after accepting multi-sport type) -->
                <div id="multi-sport-settings" class="multi-sport-panel" style="display: none;">
                    <h4 style="margin: 0 0 0.75rem 0; font-size: 0.9rem;">Multi-Sport / Multi-League Configuration</h4>

                    <div class="form-group">
                        <label for="enabled_leagues">Enabled Leagues</label>
                        <div id="enabled-leagues-picker" class="leagues-picker">
                            <span class="loading-spinner"></span> Loading leagues...
                        </div>
                        <input type="hidden" id="enabled_leagues" name="enabled_leagues"
                               value="{{ group.enabled_leagues if group and group.enabled_leagues else '[]' }}">
                        <small class="form-help">Select which leagues to search when detecting events. Leave empty for all leagues.</small>
                    </div>

                    <div class="form-row" style="margin-top: 1rem;">
                        <div class="form-group">
                            <label for="channel_sort_order">Channel Sort Order</label>
                            <select id="channel_sort_order" name="channel_sort_order" class="form-control">
                                <option value="time" {% if not group or group.channel_sort_order == 'time' %}selected{% endif %}>By Time (chronological)</option>
                                <option value="sport_time" {% if group and group.channel_sort_order == 'sport_time' %}selected{% endif %}>By Sport, then Time</option>
                                <option value="league_time" {% if group and group.channel_sort_order == 'league_time' %}selected{% endif %}>By League, then Time</option>
                            </select>
                            <small class="form-help">How to order channels within this group</small>
                        </div>

                        <div class="form-group">
                            <label for="overlap_handling">Cross-Group Event Handling</label>
                            <select id="overlap_handling" name="overlap_handling" class="form-control">
                                <option value="add_stream" {% if not group or group.overlap_handling == 'add_stream' %}selected{% endif %}>Add to existing channel, or create new</option>
                                <option value="add_only" {% if group and group.overlap_handling == 'add_only' %}selected{% endif %}>Add to existing only (no new channels)</option>
                                <option value="create_all" {% if group and group.overlap_handling == 'create_all' %}selected{% endif %}>Create separate channel for each stream</option>
                                <option value="skip" {% if group and group.overlap_handling == 'skip' %}selected{% endif %}>Skip (don't add or create)</option>
                            </select>
                            <small class="form-help">What to do when another group already has a channel for the same event</small>
                        </div>
                    </div>
                </div>
            {% endif %}

            {% if mode == 'edit' %}
            <!-- Hidden field for multi-sport mode (edit mode) -->
            <input type="hidden" id="is_multi_sport" name="is_multi_sport" value="{{ '1' if group and group.is_multi_sport else '0' }}">

            <!-- Locked Group Type Indicator (edit mode) -->
            <div class="group-type-locked" style="margin-top: 1rem;">
                <div class="locked-badge">
                    <span class="lock-icon">ðŸ”’</span>
                    <span>{% if group.is_multi_sport %}Multi-Sport / Multi-League{% else %}Single League{% endif %}</span>
                </div>
            </div>

            {% if not group.is_multi_sport %}
            <!-- Single League Edit Mode: Show parent/child selection -->
            <div class="form-group" style="margin-top: 1rem;">
                <label for="parent_group_id">Group Hierarchy</label>
                <select id="parent_group_id" name="parent_group_id" class="form-control" onchange="handleParentGroupChange()">
                    <option value="">Independent Group (creates its own channels)</option>
                </select>
                <small class="form-help">Child groups add streams to their parent's channels instead of creating new ones.</small>
            </div>

            <!-- Child Group Notice - shown when parent selected -->
            <div id="child-group-notice" class="child-group-notice" style="display: none;">
                <div class="notice-icon">â†³</div>
                <div class="notice-content">
                    <strong>Child Group Mode</strong>
                    <p>This group inherits template and channel settings from its parent. Only custom regex settings are editable below.</p>
                </div>
            </div>
            {% endif %}

            <!-- Multi-Sport Settings for edit mode (shown if group is multi-sport) -->
            {% if group and group.is_multi_sport %}
            <div id="multi-sport-settings" class="multi-sport-panel" style="display: block;">
                <h4 style="margin: 0 0 0.75rem 0; font-size: 0.9rem;">Multi-Sport / Multi-League Configuration</h4>

                <div class="form-group">
                    <label for="enabled_leagues">Enabled Leagues</label>
                    <div id="enabled-leagues-picker" class="leagues-picker">
                        <span class="loading-spinner"></span> Loading leagues...
                    </div>
                    <input type="hidden" id="enabled_leagues" name="enabled_leagues"
                           value="{{ group.enabled_leagues if group.enabled_leagues else '[]' }}">
                    <small class="form-help">Select which leagues to search when detecting events. Leave empty for all leagues.</small>
                </div>

                <div class="form-row" style="margin-top: 1rem;">
                    <div class="form-group">
                        <label for="channel_sort_order">Channel Sort Order</label>
                        <select id="channel_sort_order" name="channel_sort_order" class="form-control">
                            <option value="time" {% if group.channel_sort_order == 'time' %}selected{% endif %}>By Time (chronological)</option>
                            <option value="sport_time" {% if group.channel_sort_order == 'sport_time' %}selected{% endif %}>By Sport, then Time</option>
                            <option value="league_time" {% if group.channel_sort_order == 'league_time' %}selected{% endif %}>By League, then Time</option>
                        </select>
                        <small class="form-help">How to order channels within this group</small>
                    </div>

                    <div class="form-group">
                        <label for="overlap_handling">Cross-Group Event Handling</label>
                        <select id="overlap_handling" name="overlap_handling" class="form-control">
                            <option value="add_stream" {% if group.overlap_handling == 'add_stream' %}selected{% endif %}>Add to existing channel, or create new</option>
                            <option value="add_only" {% if group.overlap_handling == 'add_only' %}selected{% endif %}>Add to existing only (no new channels)</option>
                            <option value="create_all" {% if group.overlap_handling == 'create_all' %}selected{% endif %}>Create separate channel for each stream</option>
                            <option value="skip" {% if group.overlap_handling == 'skip' %}selected{% endif %}>Skip (don't add or create)</option>
                        </select>
                        <small class="form-help">What to do when another group already has a channel for the same event</small>
                    </div>
                </div>
            </div>
            {% endif %}
            {% endif %}
        </div>

        <!-- Independent Group Settings (hidden for child groups, locked in add mode until type accepted) -->
        <div id="independent-settings"{% if mode == 'add' %} class="locked-section"{% endif %}>
            <div class="form-section">
                <h2>Template & Channel Settings</h2>

                <div class="form-group">
                    <label for="event_template_id">Event Template <span class="required">*</span></label>
                    <select id="event_template_id" name="event_template_id" class="form-control" required>
                        <option value="" disabled>Select a template...</option>
                        {% for template in event_templates %}
                        <option value="{{ template.id }}" {% if group and group.event_template_id == template.id %}selected{% endif %}>
                            {{ template.name }}
                        </option>
                        {% endfor %}
                    </select>
                    <small class="form-help">Required. Controls EPG title, description, and channel naming.</small>
                </div>

                <div class="form-group">
                <label for="channel_start">Channel Start Number</label>
                <input type="number" id="channel_start" name="channel_start" class="form-control"
                       placeholder="Auto-calculated if empty" min="1" max="9999"
                       value="{{ group.channel_start if group and group.channel_start else '' }}">
                <small class="form-help">First channel number for created channels (max 9999). Leave empty to auto-assign next available range.</small>
            </div>

            <div class="form-group">
                <label for="channel_group_id">Channel Group</label>
                <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;">
                    <input type="text" id="group-filter" class="form-control" placeholder="Filter groups..." style="flex: 1;" oninput="filterChannelGroups()">
                    <button type="button" class="btn btn-sm btn-secondary" onclick="toggleCreateGroupForm()">+ New</button>
                </div>
                <div id="create-group-form" style="display: none; margin-bottom: 0.5rem; padding: 0.5rem; background: var(--bg-tertiary); border-radius: 4px;">
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="text" id="new-group-name" class="form-control" placeholder="New group name..." style="flex: 1;">
                        <button type="button" class="btn btn-sm btn-success" onclick="createGroupInline()">Create</button>
                        <button type="button" class="btn btn-sm btn-secondary" onclick="toggleCreateGroupForm()">Cancel</button>
                    </div>
                    <div id="create-group-status" style="margin-top: 0.25rem; font-size: 0.75rem;"></div>
                </div>
                <select id="channel_group_id" name="channel_group_id" class="form-control" size="5" style="height: auto;">
                    <option value="">Loading groups...</option>
                </select>
                <small class="form-help">Dispatcharr group to assign created channels to. Only non-M3U groups shown.</small>
            </div>

            <div class="form-group">
                <label for="stream_profile_id">Stream Profile</label>
                <div style="margin-bottom: 0.5rem;">
                    <input type="text" id="profile-filter" class="form-control" placeholder="Filter profiles..." oninput="filterStreamProfiles()">
                </div>
                <select id="stream_profile_id" name="stream_profile_id" class="form-control" size="4" style="height: auto;">
                    <option value="">Loading profiles...</option>
                </select>
                <small class="form-help">Leave blank to use default.</small>
            </div>

            <div class="form-group">
                <label for="channel_profile_ids">Channel Profiles</label>
                <div style="margin-bottom: 0.5rem; display: flex; gap: 0.5rem;">
                    <input type="text" id="channel-profile-filter" class="form-control" placeholder="Filter profiles..." oninput="filterChannelProfiles()" style="flex: 1;">
                    <button type="button" class="btn btn-secondary btn-sm" onclick="clearChannelProfiles()" title="Clear selection">Clear</button>
                    <button type="button" class="btn btn-sm btn-secondary" onclick="toggleCreateChannelProfileForm()">+ New</button>
                </div>
                <div id="create-channel-profile-form" style="display: none; margin-bottom: 0.5rem; padding: 0.5rem; background: var(--bg-tertiary); border-radius: 4px;">
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="text" id="new-channel-profile-name" class="form-control" placeholder="New profile name..." style="flex: 1;">
                        <button type="button" class="btn btn-sm btn-success" onclick="createChannelProfileInline()">Create</button>
                        <button type="button" class="btn btn-sm btn-secondary" onclick="toggleCreateChannelProfileForm()">Cancel</button>
                    </div>
                    <div id="create-channel-profile-status" style="margin-top: 0.25rem; font-size: 0.75rem;"></div>
                </div>
                <select id="channel_profile_ids" name="channel_profile_ids" class="form-control" size="4" style="height: auto;" multiple>
                    <option value="">Loading profiles...</option>
                </select>
                <small class="form-help">Ctrl/Cmd+click to select multiple. Use Clear button to deselect all.</small>
                </div>
            </div>
        </div><!-- end independent-settings -->

        <!-- Custom Regex Section (Collapsible) - Available for both parent and child groups -->
        <div class="form-section collapsible-section{% if mode == 'add' %} locked-section{% endif %}" id="custom-regex-section">
            <h2 class="collapsible-header" onclick="toggleSection('custom-regex')">
                <span class="collapse-arrow" id="custom-regex-arrow">â–¶</span>
                Custom Regex
            </h2>
            <div id="custom-regex-content" class="collapsible-content" style="display: none;">

                <!-- Stream Filtering Subsection -->
                <div class="subsection">
                    <h3 class="subsection-header">Stream Filtering</h3>
                    <p class="section-description">Streams are automatically filtered to only include game streams (those with vs, @, or at).</p>

                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="skip_builtin_filter" name="skip_builtin_filter"
                                   {% if group and group.skip_builtin_filter %}checked{% endif %}>
                            <span>Skip built-in game detection</span>
                        </label>
                        <small class="form-help">Disable automatic filtering when stream names don't use standard separators (vs, @, at).</small>
                    </div>

                    <div class="form-group regex-field-group">
                        <div class="regex-field-header">
                            <label class="checkbox-label">
                                <input type="checkbox" id="stream_include_regex_enabled" name="stream_include_regex_enabled"
                                       {% if group and group.stream_include_regex_enabled %}checked{% endif %}
                                       onchange="toggleRegexField('stream_include_regex')">
                                <span>Inclusion Pattern</span>
                            </label>
                        </div>
                        <input type="text" id="stream_include_regex" name="stream_include_regex"
                               class="form-control mono regex-input {% if not group or not group.stream_include_regex_enabled %}disabled-field{% endif %}"
                               placeholder="e.g., Gonzaga|Washington State|Eastern Washington"
                               value="{{ group.stream_include_regex if group and group.stream_include_regex else '' }}"
                               {% if not group or not group.stream_include_regex_enabled %}disabled{% endif %}>
                        <small class="form-help">Only streams matching this pattern will be processed.</small>
                    </div>

                    <div class="form-group regex-field-group">
                        <div class="regex-field-header">
                            <label class="checkbox-label">
                                <input type="checkbox" id="stream_exclude_regex_enabled" name="stream_exclude_regex_enabled"
                                       {% if group and group.stream_exclude_regex_enabled %}checked{% endif %}
                                       onchange="toggleRegexField('stream_exclude_regex')">
                                <span>Exclusion Pattern</span>
                            </label>
                        </div>
                        <input type="text" id="stream_exclude_regex" name="stream_exclude_regex"
                               class="form-control mono regex-input {% if not group or not group.stream_exclude_regex_enabled %}disabled-field{% endif %}"
                               placeholder="e.g., \(ES\)|\(ALT\)|All.?Star"
                               value="{{ group.stream_exclude_regex if group and group.stream_exclude_regex else '' }}"
                               {% if not group or not group.stream_exclude_regex_enabled %}disabled{% endif %}>
                        <small class="form-help">Streams matching this pattern will be excluded.</small>
                    </div>
                </div>

                <!-- Custom Team Matching Subsection -->
                <div class="subsection">
                    <h3 class="subsection-header">Team Matching</h3>
                    <p class="section-description">Override built-in matching with custom regex patterns. Enable individual fields as needed.</p>

                    <div class="form-group regex-field-group">
                        <div class="regex-field-header">
                            <label class="checkbox-label">
                                <input type="checkbox" id="custom_regex_teams_enabled" name="custom_regex_teams_enabled"
                                       {% if group and group.custom_regex_teams_enabled %}checked{% endif %}
                                       onchange="toggleRegexField('custom_regex_teams')">
                                <span>Teams Pattern</span>
                            </label>
                        </div>
                        <input type="text" id="custom_regex_teams" name="custom_regex_teams"
                               class="form-control mono regex-input {% if not group or not group.custom_regex_teams_enabled %}disabled-field{% endif %}"
                               placeholder="(?P<team1>[A-Z]{2,3})\s*[@vs]+\s*(?P<team2>[A-Z]{2,3})"
                               value="{{ group.custom_regex_teams if group and group.custom_regex_teams else '' }}"
                               {% if not group or not group.custom_regex_teams_enabled %}disabled{% endif %}>
                    </div>

                    <div class="form-row">
                        <div class="form-group regex-field-group">
                            <div class="regex-field-header">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="custom_regex_date_enabled" name="custom_regex_date_enabled"
                                           {% if group and group.custom_regex_date_enabled %}checked{% endif %}
                                           onchange="toggleRegexField('custom_regex_date')">
                                    <span>Date Pattern</span>
                                </label>
                            </div>
                            <input type="text" id="custom_regex_date" name="custom_regex_date"
                                   class="form-control mono regex-input {% if not group or not group.custom_regex_date_enabled %}disabled-field{% endif %}"
                                   placeholder="(?P<date>\d{1,2}/\d{1,2})"
                                   value="{{ group.custom_regex_date if group and group.custom_regex_date else '' }}"
                                   {% if not group or not group.custom_regex_date_enabled %}disabled{% endif %}>
                        </div>

                        <div class="form-group regex-field-group">
                            <div class="regex-field-header">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="custom_regex_time_enabled" name="custom_regex_time_enabled"
                                           {% if group and group.custom_regex_time_enabled %}checked{% endif %}
                                           onchange="toggleRegexField('custom_regex_time')">
                                    <span>Time Pattern</span>
                                </label>
                            </div>
                            <input type="text" id="custom_regex_time" name="custom_regex_time"
                                   class="form-control mono regex-input {% if not group or not group.custom_regex_time_enabled %}disabled-field{% endif %}"
                                   placeholder="(?P<time>\d{1,2}:\d{2}\s*(?:AM|PM)?)"
                                   value="{{ group.custom_regex_time if group and group.custom_regex_time else '' }}"
                                   {% if not group or not group.custom_regex_time_enabled %}disabled{% endif %}>
                        </div>
                    </div>

                    {% if mode == 'edit' %}
                    <div class="form-group">
                        <button type="button" class="btn btn-secondary" onclick="testRegexPatterns()" id="test-regex-btn">
                            Test Patterns
                        </button>
                        <div id="regex-test-results" style="margin-top: 0.75rem;"></div>
                    </div>
                    {% endif %}
                </div>
            </div>
        </div>

        <!-- Form Actions -->
        <div class="form-actions">
            <button type="submit" class="btn btn-primary">
                {% if mode == 'add' %}Add Event Group{% else %}Save Changes{% endif %}
            </button>
            <a href="{{ url_for('event_groups_list') }}" class="btn btn-secondary">Cancel</a>
        </div>
    </form>
</div>

<script>
// Channel groups data
let channelGroups = [];
let allChannelGroups = [];

// Stream profiles data
let streamProfiles = [];
let allStreamProfiles = [];

// Channel profiles data
let channelProfiles = [];

// Event groups for parent selection
let eventGroups = [];

// Initialize on page load
document.addEventListener('DOMContentLoaded', async function() {
    await Promise.all([loadLeagues(), loadChannelGroups(), loadStreamProfiles(), loadChannelProfiles(), loadEventGroups()]);
    {% if mode == 'edit' and group.channel_group_id %}
    document.getElementById('channel_group_id').value = '{{ group.channel_group_id }}';
    {% endif %}
    {% if mode == 'edit' and group.stream_profile_id %}
    document.getElementById('stream_profile_id').value = '{{ group.stream_profile_id }}';
    {% endif %}
    {% if mode == 'edit' and group.channel_profile_ids %}
    // Set selected channel profiles (multiselect)
    const profileIds = {{ group.channel_profile_ids | safe }};
    const profileSelect = document.getElementById('channel_profile_ids');
    profileIds.forEach(id => {
        const option = profileSelect.querySelector(`option[value="${id}"]`);
        if (option) option.selected = true;
    });
    {% endif %}
    {% if mode == 'edit' and group.parent_group_id %}
    document.getElementById('parent_group_id').value = '{{ group.parent_group_id }}';
    handleParentGroupChange();  // Update UI based on parent selection
    {% endif %}
    {% if mode == 'edit' and group.is_multi_sport %}
    // Initialize multi-sport leagues picker for edit mode
    loadLeaguesPicker();
    {% endif %}
});

// League options loaded from database
let leaguesBySport = {};

// Track if group type has been accepted (add mode only)
let groupTypeAccepted = false;

/**
 * Accept the group type selection and unlock the rest of the form.
 * Called when user clicks "Continue" after selecting Single League or Multi-Sport.
 */
function acceptGroupType() {
    const selectedType = document.querySelector('input[name="group_type_choice"]:checked').value;
    const isMultiSport = selectedType === 'multi';

    // Update hidden field
    document.getElementById('is_multi_sport').value = isMultiSport ? '1' : '0';

    // Hide selector, show locked indicator
    document.getElementById('group-type-selector').style.display = 'none';
    const lockedDiv = document.getElementById('group-type-locked');
    lockedDiv.style.display = 'block';
    document.getElementById('locked-type-label').textContent = isMultiSport ? 'Multi-Sport / Multi-League' : 'Single League';

    // Show appropriate settings section
    if (isMultiSport) {
        document.getElementById('multi-sport-settings').style.display = 'block';
        document.getElementById('single-league-settings').style.display = 'none';

        // Set dummy values for sport/league (multi-sport doesn't use them)
        const sportSelect = document.getElementById('assigned_sport');
        const leagueSelect = document.getElementById('assigned_league');
        if (sportSelect) {
            sportSelect.innerHTML = '<option value="multi" selected>N/A</option>';
            sportSelect.removeAttribute('required');
        }
        if (leagueSelect) {
            leagueSelect.innerHTML = '<option value="multi" selected>N/A</option>';
            leagueSelect.removeAttribute('required');
        }

        // Load leagues picker for multi-sport
        loadLeaguesPicker();
    } else {
        document.getElementById('single-league-settings').style.display = 'block';
        document.getElementById('multi-sport-settings').style.display = 'none';

        // Populate parent group dropdown for single-league mode
        populateParentGroups();
    }

    // Unlock all form sections (template, channel config, regex, etc.)
    document.getElementById('independent-settings').classList.remove('locked-section');
    document.getElementById('custom-regex-section').classList.remove('locked-section');

    groupTypeAccepted = true;
}

async function loadLeagues() {
    try {
        const response = await fetch('/api/leagues');
        const data = await response.json();

        if (data.leagues) {
            // Group leagues by sport
            leaguesBySport = {};
            data.leagues.forEach(league => {
                if (!leaguesBySport[league.sport]) {
                    leaguesBySport[league.sport] = [];
                }
                leaguesBySport[league.sport].push({
                    value: league.code,
                    label: league.name
                });
            });

            // Update sport dropdown with available sports (no multi-sport option - handled by radio)
            const sportSelect = document.getElementById('assigned_sport');
            if (sportSelect) {
                const currentValue = sportSelect.value;
                sportSelect.innerHTML = '<option value="">Select sport...</option>';

                // Add regular sports only
                Object.keys(leaguesBySport).sort().forEach(sport => {
                    const option = document.createElement('option');
                    option.value = sport;
                    option.textContent = sport.charAt(0).toUpperCase() + sport.slice(1);
                    sportSelect.appendChild(option);
                });
                if (currentValue) sportSelect.value = currentValue;
            }
        }
    } catch (error) {
        console.error('Error loading leagues:', error);
    }
}

function updateLeagueOptions() {
    const sport = document.getElementById('assigned_sport').value;
    const leagueSelect = document.getElementById('assigned_league');
    const leagueGroup = document.getElementById('league-group');

    // Single-league mode: just populate league dropdown based on sport selection
    if (leagueGroup) {
        leagueGroup.style.display = 'block';
    }
    leagueSelect.setAttribute('required', 'required');
    leagueSelect.innerHTML = '<option value="">Select league...</option>';

    if (sport && leaguesBySport[sport]) {
        leaguesBySport[sport].forEach(league => {
            const option = document.createElement('option');
            option.value = league.value;
            option.textContent = league.label;
            leagueSelect.appendChild(option);
        });
    }
}

async function loadChannelGroups() {
    try {
        const response = await fetch('/api/dispatcharr/channel-groups?exclude_m3u=true');
        const data = await response.json();

        if (response.ok && data.groups) {
            allChannelGroups = data.groups || [];
            channelGroups = [...allChannelGroups];
            renderChannelGroups();
        } else {
            console.error('Failed to load channel groups:', data.error);
            document.getElementById('channel_group_id').innerHTML = '<option value="">(Failed to load groups)</option>';
        }
    } catch (error) {
        console.error('Error loading channel groups:', error);
        document.getElementById('channel_group_id').innerHTML = '<option value="">(Error loading groups)</option>';
    }
}

function renderChannelGroups() {
    const select = document.getElementById('channel_group_id');
    const currentValue = select.value;

    select.innerHTML = '<option value="">&lt;No group assignment&gt;</option>';

    channelGroups.forEach(group => {
        const option = document.createElement('option');
        option.value = group.id;
        option.textContent = group.name;
        select.appendChild(option);
    });

    if (currentValue) {
        select.value = currentValue;
    }
}

function filterChannelGroups() {
    const filter = document.getElementById('group-filter').value.toLowerCase();

    if (!filter) {
        channelGroups = [...allChannelGroups];
    } else {
        channelGroups = allChannelGroups.filter(g =>
            g.name.toLowerCase().includes(filter)
        );
    }

    renderChannelGroups();
}

function toggleCreateGroupForm() {
    const form = document.getElementById('create-group-form');
    form.style.display = form.style.display === 'none' ? 'block' : 'none';
    if (form.style.display === 'block') {
        document.getElementById('new-group-name').focus();
    }
}

async function createGroupInline() {
    const name = document.getElementById('new-group-name').value.trim();
    const statusDiv = document.getElementById('create-group-status');

    if (!name) {
        statusDiv.innerHTML = '<span style="color: var(--danger);">Please enter a group name</span>';
        return;
    }

    statusDiv.innerHTML = '<span style="color: var(--text-muted);">Creating...</span>';

    try {
        const response = await fetch('/api/dispatcharr/channel-groups', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: name })
        });

        const data = await response.json();

        if (data.success) {
            statusDiv.innerHTML = '<span style="color: var(--success);">Created!</span>';
            document.getElementById('new-group-name').value = '';

            // Reload groups and select the new one
            await loadChannelGroups();
            document.getElementById('channel_group_id').value = data.group.id;

            setTimeout(() => {
                toggleCreateGroupForm();
            }, 500);
        } else {
            statusDiv.innerHTML = `<span style="color: var(--danger);">${data.error || 'Failed to create group'}</span>`;
        }
    } catch (error) {
        statusDiv.innerHTML = `<span style="color: var(--danger);">Error: ${error.message}</span>`;
    }
}

function toggleSection(sectionId) {
    const content = document.getElementById(sectionId + '-content');
    const arrow = document.getElementById(sectionId + '-arrow');

    if (content.style.display === 'none') {
        content.style.display = 'block';
        arrow.textContent = 'â–¼';
    } else {
        content.style.display = 'none';
        arrow.textContent = 'â–¶';
    }
}

function toggleRegexField(fieldId) {
    const checkbox = document.getElementById(fieldId + '_enabled');
    const input = document.getElementById(fieldId);

    if (checkbox.checked) {
        input.disabled = false;
        input.classList.remove('disabled-field');
    } else {
        input.disabled = true;
        input.classList.add('disabled-field');
    }
}

// ============================================================================
// Stream Profiles
// ============================================================================

async function loadStreamProfiles() {
    try {
        const response = await fetch('/api/dispatcharr/stream-profiles');
        const data = await response.json();

        if (response.ok && data.profiles) {
            allStreamProfiles = data.profiles || [];
            streamProfiles = [...allStreamProfiles];
            renderStreamProfiles();
        } else {
            console.error('Failed to load stream profiles:', data.error);
            document.getElementById('stream_profile_id').innerHTML = '<option value="">(Failed to load profiles)</option>';
        }
    } catch (error) {
        console.error('Error loading stream profiles:', error);
        document.getElementById('stream_profile_id').innerHTML = '<option value="">(Error loading profiles)</option>';
    }
}

function renderStreamProfiles() {
    const select = document.getElementById('stream_profile_id');
    const currentValue = select.value;

    select.innerHTML = '';

    streamProfiles.forEach(profile => {
        const option = document.createElement('option');
        option.value = profile.id;
        const activeIndicator = profile.is_active ? '' : ' (inactive)';
        option.textContent = profile.name + activeIndicator;
        select.appendChild(option);
    });

    if (currentValue) {
        select.value = currentValue;
    }
}

function filterStreamProfiles() {
    const filter = document.getElementById('profile-filter').value.toLowerCase();

    if (!filter) {
        streamProfiles = [...allStreamProfiles];
    } else {
        streamProfiles = allStreamProfiles.filter(p =>
            p.name.toLowerCase().includes(filter)
        );
    }

    renderStreamProfiles();
}

async function loadChannelProfiles() {
    try {
        const response = await fetch('/api/dispatcharr/channel-profiles');
        const data = await response.json();

        if (response.ok && data.profiles) {
            channelProfiles = data.profiles || [];
            renderChannelProfiles();
        } else {
            console.error('Failed to load channel profiles:', data.error);
            document.getElementById('channel_profile_ids').innerHTML = '<option value="">(Failed to load profiles)</option>';
        }
    } catch (error) {
        console.error('Error loading channel profiles:', error);
        document.getElementById('channel_profile_ids').innerHTML = '<option value="">(Error loading profiles)</option>';
    }
}

function renderChannelProfiles() {
    const select = document.getElementById('channel_profile_ids');
    // Get currently selected values (multiselect)
    const selectedValues = Array.from(select.selectedOptions).map(o => o.value);

    select.innerHTML = '';

    channelProfiles.forEach(profile => {
        const option = document.createElement('option');
        option.value = profile.id;
        option.textContent = profile.name;
        // Restore selection state
        if (selectedValues.includes(String(profile.id))) {
            option.selected = true;
        }
        select.appendChild(option);
    });
}

function filterChannelProfiles() {
    const filter = document.getElementById('channel-profile-filter').value.toLowerCase();
    const select = document.getElementById('channel_profile_ids');
    // Get currently selected values (multiselect)
    const selectedValues = Array.from(select.selectedOptions).map(o => o.value);

    select.innerHTML = '';

    channelProfiles.forEach(profile => {
        if (profile.name.toLowerCase().includes(filter)) {
            const option = document.createElement('option');
            option.value = profile.id;
            option.textContent = profile.name;
            // Restore selection state
            if (selectedValues.includes(String(profile.id))) {
                option.selected = true;
            }
            select.appendChild(option);
        }
    });
}

function clearChannelProfiles() {
    const select = document.getElementById('channel_profile_ids');
    Array.from(select.options).forEach(opt => opt.selected = false);
}

function toggleCreateChannelProfileForm() {
    const form = document.getElementById('create-channel-profile-form');
    form.style.display = form.style.display === 'none' ? 'block' : 'none';
    if (form.style.display === 'block') {
        document.getElementById('new-channel-profile-name').focus();
    }
}

async function createChannelProfileInline() {
    const name = document.getElementById('new-channel-profile-name').value.trim();
    const statusDiv = document.getElementById('create-channel-profile-status');

    if (!name) {
        statusDiv.innerHTML = '<span style="color: var(--danger);">Please enter a profile name</span>';
        return;
    }

    statusDiv.innerHTML = '<span style="color: var(--text-muted);">Creating...</span>';

    try {
        const response = await fetch('/api/dispatcharr/channel-profiles', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: name })
        });

        const data = await response.json();

        if (data.success) {
            statusDiv.innerHTML = '<span style="color: var(--success);">Created!</span>';
            document.getElementById('new-channel-profile-name').value = '';

            // Reload profiles and select the new one
            await loadChannelProfiles();
            const profileSelect = document.getElementById('channel_profile_ids');
            const newOption = profileSelect.querySelector(`option[value="${data.profile_id}"]`);
            if (newOption) newOption.selected = true;

            setTimeout(() => {
                toggleCreateChannelProfileForm();
            }, 500);
        } else {
            statusDiv.innerHTML = `<span style="color: var(--danger);">${data.error || 'Failed to create profile'}</span>`;
        }
    } catch (error) {
        statusDiv.innerHTML = `<span style="color: var(--danger);">Error: ${error.message}</span>`;
    }
}

// ============================================================================
// Event Groups (for parent selection)
// ============================================================================

async function loadEventGroups() {
    try {
        const response = await fetch('/api/event-epg/groups');
        const data = await response.json();

        if (response.ok && data.groups) {
            eventGroups = data.groups || [];
            renderEventGroups();
        } else {
            console.error('Failed to load event groups:', data.error);
        }
    } catch (error) {
        console.error('Error loading event groups:', error);
    }
}

/**
 * Populate parent groups dropdown (called after group type accepted).
 * Only shows single-league parent groups (multi-sport groups can't be parents).
 */
function populateParentGroups() {
    renderEventGroups();
}

function renderEventGroups() {
    const select = document.getElementById('parent_group_id');
    if (!select) return;

    const currentValue = select.value;

    // Keep the "None" option
    select.innerHTML = '<option value="">Independent Group (creates its own channels)</option>';

    {% if mode == 'edit' %}
    const currentGroupId = {{ group.id }};
    {% else %}
    const currentGroupId = null;
    {% endif %}

    // Filter to single-league parent groups only (multi-sport groups can't have children)
    const eligibleParents = eventGroups.filter(group => {
        if (currentGroupId && group.id === currentGroupId) return false;
        if (group.parent_group_id) return false;  // Already a child
        if (group.is_multi_sport) return false;   // Multi-sport groups can't be parents
        return true;
    });

    if (eligibleParents.length > 0) {
        const separator = document.createElement('option');
        separator.disabled = true;
        separator.textContent = 'â”€â”€ Child of: â”€â”€';
        select.appendChild(separator);
    }

    eligibleParents.forEach(group => {
        const option = document.createElement('option');
        option.value = group.id;
        option.textContent = `â†³ ${group.group_name} (${group.assigned_league.toUpperCase()})`;
        select.appendChild(option);
    });

    if (currentValue) {
        select.value = currentValue;
    }

    // Trigger UI update based on current value
    handleParentGroupChange();
}

function handleParentGroupChange() {
    const parentSelect = document.getElementById('parent_group_id');
    const isChildGroup = parentSelect.value !== '';

    const notice = document.getElementById('child-group-notice');
    const independentSettings = document.getElementById('independent-settings');
    const templateSelect = document.getElementById('event_template_id');

    // Sport/league elements (only exist in add mode)
    const sportSelect = document.getElementById('assigned_sport');
    const leagueSelect = document.getElementById('assigned_league');
    const sportLeagueRow = document.getElementById('sport-league-row');
    const sportRequired = document.getElementById('sport-required');
    const leagueRequired = document.getElementById('league-required');

    if (isChildGroup) {
        // Show child notice, hide independent settings
        notice.style.display = 'flex';
        independentSettings.classList.add('hidden');
        // Template not required for child groups
        templateSelect.removeAttribute('required');

        // Auto-expand the regex section for child groups (it's the only thing they can edit)
        const regexContent = document.getElementById('custom-regex-content');
        const regexArrow = document.getElementById('custom-regex-arrow');
        if (regexContent && regexContent.style.display === 'none') {
            regexContent.style.display = 'block';
            if (regexArrow) regexArrow.textContent = 'â–¼';
        }

        // In add mode: populate and disable sport/league from parent
        if (sportSelect && leagueSelect) {
            const parentId = parseInt(parentSelect.value);
            const parentGroup = eventGroups.find(g => g.id === parentId);

            if (parentGroup) {
                // Set sport and trigger league population
                sportSelect.value = parentGroup.assigned_sport;
                sportSelect.disabled = true;
                sportSelect.removeAttribute('required');  // Backend inherits from parent
                updateLeagueOptions();

                // Set league after options are populated
                setTimeout(() => {
                    leagueSelect.value = parentGroup.assigned_league;
                    leagueSelect.disabled = true;
                    leagueSelect.removeAttribute('required');  // Backend inherits from parent
                }, 50);

                // Hide required asterisks (values enforced from parent)
                if (sportRequired) sportRequired.style.display = 'none';
                if (leagueRequired) leagueRequired.style.display = 'none';

                // Grey out the row visually
                if (sportLeagueRow) sportLeagueRow.style.opacity = '0.6';
            }
        }
    } else {
        // Hide child notice, show independent settings
        notice.style.display = 'none';
        independentSettings.classList.remove('hidden');
        // Template required for independent groups
        templateSelect.setAttribute('required', 'required');

        // In add mode: re-enable sport/league selection
        if (sportSelect && leagueSelect) {
            sportSelect.disabled = false;
            sportSelect.setAttribute('required', 'required');
            leagueSelect.disabled = false;
            leagueSelect.setAttribute('required', 'required');

            // Show required asterisks
            if (sportRequired) sportRequired.style.display = 'inline';
            if (leagueRequired) leagueRequired.style.display = 'inline';

            // Remove grey out
            if (sportLeagueRow) sportLeagueRow.style.opacity = '1';
        }
    }
}

{% if mode == 'edit' %}
async function testRegexPatterns() {
    const teamsPattern = document.getElementById('custom_regex_teams').value.trim();
    const datePattern = document.getElementById('custom_regex_date').value.trim();
    const timePattern = document.getElementById('custom_regex_time').value.trim();
    const excludePattern = document.getElementById('stream_exclude_regex').value.trim();
    const resultsDiv = document.getElementById('regex-test-results');
    const testBtn = document.getElementById('test-regex-btn');

    if (!teamsPattern) {
        resultsDiv.innerHTML = '<span style="color: var(--warning);">Teams pattern is required.</span>';
        return;
    }

    // Validate that pattern has required named groups
    if (!teamsPattern.includes('(?P<team1>') || !teamsPattern.includes('(?P<team2>')) {
        resultsDiv.innerHTML = '<span style="color: var(--warning);">Pattern must include (?P&lt;team1&gt;...) and (?P&lt;team2&gt;...) groups.</span>';
        return;
    }

    testBtn.disabled = true;
    testBtn.textContent = 'Testing...';
    resultsDiv.innerHTML = '<span style="color: var(--text-muted);">Testing patterns against streams...</span>';

    try {
        const response = await fetch('/api/event-epg/groups/{{ group.id }}/test-regex', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                teams_pattern: teamsPattern,
                date_pattern: datePattern || null,
                time_pattern: timePattern || null,
                exclude_pattern: excludePattern || null
            })
        });

        const data = await response.json();

        if (!response.ok) {
            resultsDiv.innerHTML = `<span style="color: var(--danger);">Error: ${escapeHtml(data.error)}</span>`;
            return;
        }

        let html = '';
        const matched = data.matched || 0;
        const excluded = data.excluded || 0;
        const total = data.tested || 0;
        const testedAfterExclude = total - excluded;
        const percentage = testedAfterExclude > 0 ? Math.round((matched / testedAfterExclude) * 100) : 0;

        html = `<div style="margin-bottom: 0.5rem;">
            <strong>${matched}/${testedAfterExclude}</strong> streams matched (${percentage}%)`;
        if (excluded > 0) {
            html += ` Â· <span style="color: var(--warning);">${excluded} excluded</span>`;
        }
        html += `</div>`;

        if (data.results && data.results.length > 0) {
            html += '<div class="test-results-list">';
            data.results.forEach(result => {
                let icon, color;
                if (result.excluded) {
                    icon = 'âŠ˜';
                    color = 'var(--warning)';
                } else if (result.matched) {
                    icon = 'âœ“';
                    color = 'var(--success)';
                } else {
                    icon = 'âœ—';
                    color = 'var(--danger)';
                }
                html += `<div class="test-result-item">
                    <div style="color: ${color}; display: flex; align-items: center; gap: 0.25rem;">
                        <span>${icon}</span>
                        <div class="stream-name-scroll">
                            <code>${escapeHtml(result.stream_name)}</code>
                        </div>
                    </div>`;
                if (result.matched) {
                    html += `<div class="test-result-detail">
                        ${escapeHtml(result.raw_team1)} â†’ ${escapeHtml(result.resolved_team1)}<br>
                        ${escapeHtml(result.raw_team2)} â†’ ${escapeHtml(result.resolved_team2)}`;
                    if (result.game_date || result.game_time) {
                        html += `<br>Date/Time: ${result.game_date || '-'} ${result.game_time || '-'}`;
                    }
                    html += '</div>';
                } else if (result.error) {
                    html += `<div class="test-result-detail" style="color: ${result.excluded ? 'var(--warning)' : 'var(--danger)'};">${escapeHtml(result.error)}</div>`;
                }
                html += '</div>';
            });
            html += '</div>';
        }

        resultsDiv.innerHTML = html;
    } catch (error) {
        resultsDiv.innerHTML = `<span style="color: var(--danger);">Error: ${escapeHtml(error.message)}</span>`;
    } finally {
        testBtn.disabled = false;
        testBtn.textContent = 'Test Patterns';
    }
}
{% endif %}

function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Form submission
document.getElementById('event-group-form').addEventListener('submit', async function(e) {
    e.preventDefault();

    const formData = new FormData(this);
    const data = {};

    // Checkbox fields that need boolean handling
    const checkboxFields = [
        'skip_builtin_filter',
        'stream_include_regex_enabled',
        'stream_exclude_regex_enabled',
        'custom_regex_teams_enabled',
        'custom_regex_date_enabled',
        'custom_regex_time_enabled'
    ];

    formData.forEach((value, key) => {
        // Skip channel_profile_ids - handled separately as multiselect
        if (key === 'channel_profile_ids') return;

        if (value !== '' && value !== null) {
            // Convert numeric fields
            if (['channel_start', 'channel_group_id', 'stream_profile_id', 'event_template_id', 'dispatcharr_group_id', 'dispatcharr_account_id', 'parent_group_id'].includes(key)) {
                data[key] = value ? parseInt(value) : null;
            } else if (checkboxFields.includes(key)) {
                data[key] = true;
            } else {
                data[key] = value;
            }
        }
    });

    // Handle unchecked checkboxes - set to false
    checkboxFields.forEach(field => {
        if (!formData.has(field)) {
            data[field] = false;
        }
    });

    // Handle channel_profile_ids multiselect
    const profileSelect = document.getElementById('channel_profile_ids');
    const selectedProfileIds = Array.from(profileSelect.selectedOptions)
        .map(o => parseInt(o.value))
        .filter(id => !isNaN(id));
    data.channel_profile_ids = selectedProfileIds.length > 0 ? selectedProfileIds : null;

    // Handle is_multi_sport - convert "0"/"1" to boolean
    const isMultiSport = document.getElementById('is_multi_sport');
    data.is_multi_sport = isMultiSport && isMultiSport.value === '1';

    // Get channel_group_name from selected option text
    const channelGroupSelect = document.getElementById('channel_group_id');
    if (channelGroupSelect.value) {
        const selectedOption = channelGroupSelect.options[channelGroupSelect.selectedIndex];
        if (selectedOption) {
            data.channel_group_name = selectedOption.textContent.trim();
        }
    }

    {% if mode == 'edit' %}
    const url = '/api/event-epg/groups/{{ group.id }}';
    const method = 'PATCH';
    {% else %}
    const url = '/api/event-epg/groups';
    const method = 'POST';
    {% endif %}

    try {
        const response = await fetch(url, {
            method: method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });

        const result = await response.json();

        if (response.ok) {
            window.location.href = '{{ url_for("event_groups_list") }}';
        } else {
            alert('Error: ' + (result.error || 'Failed to save'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
});

// ============================================================================
// Multi-Sport / Multi-League Mode Functions
// ============================================================================

// League definitions for the picker
// Sorted alphabetically by sport name
// League values use ESPN API slugs for consistency with database storage
// The database normalizes all league codes to these slugs via normalize_league_codes()
const multiSportLeagues = {
    'baseball': [
        { value: 'mlb', label: 'MLB' },
    ],
    'basketball': [
        { value: 'nba', label: 'NBA' },
        { value: 'nba-development', label: 'NBA G-League' },
        { value: 'wnba', label: 'WNBA' },
        { value: 'mens-college-basketball', label: 'NCAA Men\'s Basketball' },
        { value: 'womens-college-basketball', label: 'NCAA Women\'s Basketball' },
    ],
    'football': [
        { value: 'nfl', label: 'NFL' },
        { value: 'college-football', label: 'NCAA Football' },
    ],
    'hockey': [
        { value: 'nhl', label: 'NHL' },
        { value: 'mens-college-hockey', label: 'NCAA Men\'s Hockey' },
        { value: 'womens-college-hockey', label: 'NCAA Women\'s Hockey' },
    ],
    'soccer': [
        { value: 'usa.ncaa.m.1', label: 'NCAA Men\'s Soccer' },
        { value: 'usa.ncaa.w.1', label: 'NCAA Women\'s Soccer' },
        { value: 'soccer_all', label: 'Professional Soccer (All)' },
    ],
    'volleyball': [
        { value: 'mens-college-volleyball', label: 'NCAA Men\'s Volleyball' },
        { value: 'womens-college-volleyball', label: 'NCAA Women\'s Volleyball' },
    ],
};

// Soccer professional leagues uses SoccerMultiLeague cache with 240+ leagues
const SOCCER_ENABLED_VALUE = 'soccer_all';

function loadLeaguesPicker() {
    const pickerDiv = document.getElementById('enabled-leagues-picker');
    const hiddenInput = document.getElementById('enabled_leagues');

    // Parse current selection
    let selected = [];
    try {
        selected = JSON.parse(hiddenInput.value || '[]');
    } catch (e) {
        selected = [];
    }

    // Count total leagues
    let totalLeagues = 0;
    Object.values(multiSportLeagues).forEach(leagues => totalLeagues += leagues.length);

    // Build the picker HTML with Select All / Clear buttons
    let html = `
        <div class="leagues-picker-actions" style="margin-bottom: 0.75rem; display: flex; gap: 0.5rem;">
            <button type="button" class="btn btn-sm btn-secondary" onclick="selectAllLeagues()">Select All</button>
            <button type="button" class="btn btn-sm btn-secondary" onclick="clearAllLeagues()">Clear All</button>
        </div>
    `;

    html += '<div class="leagues-picker-grid">';

    // Add all sports including soccer
    Object.entries(multiSportLeagues).forEach(([sport, leagues]) => {
        html += `<div class="leagues-sport-group">`;
        html += `<div class="leagues-sport-header">${sport.charAt(0).toUpperCase() + sport.slice(1)}</div>`;
        html += `<div class="leagues-list">`;

        leagues.forEach(league => {
            const checked = selected.includes(league.value) ? 'checked' : '';
            // Add helper text for Professional Soccer
            const helperText = league.value === SOCCER_ENABLED_VALUE
                ? '<small style="color: var(--text-muted); font-size: 0.65rem; display: block; margin-left: 1.25rem;">240+ leagues via cache</small>'
                : '';
            html += `
                <label class="league-checkbox">
                    <input type="checkbox" value="${league.value}" ${checked} onchange="updateEnabledLeagues()">
                    <span>${league.label}</span>
                </label>
                ${helperText}
            `;
        });

        html += `</div></div>`;
    });

    html += '</div>';

    // Count selected
    const selectedCount = selected.length;
    html += `<div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-muted);">
        Selected: <span id="selected-leagues-count">${selectedCount}</span> / ${totalLeagues} sports/leagues
        ${selectedCount === 0 ? '(all will be searched)' : ''}
    </div>`;

    pickerDiv.innerHTML = html;
}

function selectAllLeagues() {
    const checkboxes = document.querySelectorAll('#enabled-leagues-picker input[type="checkbox"]');
    checkboxes.forEach(cb => cb.checked = true);
    updateEnabledLeagues();
}

function clearAllLeagues() {
    const checkboxes = document.querySelectorAll('#enabled-leagues-picker input[type="checkbox"]');
    checkboxes.forEach(cb => cb.checked = false);
    updateEnabledLeagues();
}

function updateEnabledLeagues() {
    const checkboxes = document.querySelectorAll('#enabled-leagues-picker input[type="checkbox"]');
    const hiddenInput = document.getElementById('enabled_leagues');
    const countSpan = document.getElementById('selected-leagues-count');

    const selected = [];
    checkboxes.forEach(cb => {
        if (cb.checked) {
            selected.push(cb.value);
        }
    });

    hiddenInput.value = JSON.stringify(selected);

    if (countSpan) {
        countSpan.textContent = selected.length;
        const hint = selected.length === 0 ? ' (all leagues will be searched)' : '';
        countSpan.parentElement.innerHTML = `Selected: <span id="selected-leagues-count">${selected.length}</span> leagues${hint}`;
    }
}

</script>

<style>
.form-container {
    max-width: 900px;
    margin: 0 auto;
    padding: 2rem 0;
}

.page-header {
    margin-bottom: 2rem;
}

.page-header h1 {
    margin: 0 0 0.5rem 0;
    font-size: 2rem;
    color: var(--text-primary);
}

.page-subtitle {
    margin: 0;
    color: var(--text-muted);
    font-size: 1rem;
}

.form-section {
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
}

.form-section h2 {
    margin: 0 0 0.5rem 0;
    font-size: 1.1rem;
    color: var(--text-primary);
}

.section-description {
    color: var(--text-muted);
    font-size: 0.875rem;
    margin: 0 0 1.25rem 0;
}

.group-info-display {
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 1rem;
    margin-bottom: 1.25rem;
}

/* Child Group Notice */
.child-group-notice {
    display: flex;
    gap: 1rem;
    background: rgba(168, 85, 247, 0.1);
    border: 1px solid rgba(168, 85, 247, 0.3);
    border-radius: 8px;
    padding: 1rem;
    margin-top: 1rem;
}

.child-group-notice .notice-icon {
    font-size: 1.5rem;
    color: #a855f7;
    flex-shrink: 0;
}

.child-group-notice .notice-content strong {
    display: block;
    color: #c4b5fd;
    margin-bottom: 0.25rem;
}

.child-group-notice .notice-content p {
    margin: 0;
    font-size: 0.875rem;
    color: var(--text-muted);
}

.light-theme .child-group-notice {
    background: rgba(168, 85, 247, 0.08);
}

.light-theme .child-group-notice .notice-content strong {
    color: #7c3aed;
}

/* Locked section state - visible but disabled until group type selected */
.locked-section {
    opacity: 0.4;
    pointer-events: none;
    user-select: none;
    position: relative;
}

.locked-section::before {
    content: 'Select group type above to continue';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    padding: 0.5rem 1rem;
    border-radius: 6px;
    font-size: 0.85rem;
    color: var(--text-muted);
    z-index: 10;
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.2s;
}

.locked-section:hover::before {
    opacity: 1;
}

/* Independent settings hidden state (for child groups) */
#independent-settings.hidden {
    display: none;
}

/* Group Type Selector (add mode) */
.group-type-selector {
    margin-top: 1rem;
    padding: 1.25rem;
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 8px;
}

.group-type-selector .form-label {
    display: block;
    font-weight: 600;
    margin-bottom: 0.75rem;
    color: var(--text);
}

.group-type-options {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.group-type-option {
    display: flex;
    align-items: flex-start;
    gap: 0.75rem;
    padding: 1rem;
    background: var(--bg-secondary);
    border: 2px solid var(--border);
    border-radius: 6px;
    cursor: pointer;
    transition: border-color 0.2s, background-color 0.2s;
}

.group-type-option:hover {
    border-color: var(--primary);
    background: var(--bg-hover);
}

.group-type-option input[type="radio"] {
    margin-top: 0.25rem;
    accent-color: var(--primary);
}

.group-type-option input[type="radio"]:checked + .option-content strong {
    color: var(--primary);
}

.group-type-option:has(input:checked) {
    border-color: var(--primary);
    background: rgba(59, 130, 246, 0.1);
}

.option-content {
    flex: 1;
}

.option-content strong {
    display: block;
    margin-bottom: 0.25rem;
    color: var(--text);
}

.option-content span {
    font-size: 0.85rem;
    color: var(--text-muted);
}

/* Locked Group Type Badge */
.group-type-locked {
    margin-top: 1rem;
}

.locked-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 6px;
    font-size: 0.9rem;
    color: var(--text-muted);
}

.locked-badge .lock-icon {
    font-size: 0.85rem;
}

.form-group {
    margin-bottom: 1.25rem;
}

.form-group:last-child {
    margin-bottom: 0;
}

.form-group label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: 500;
    color: var(--text-secondary);
    font-size: 0.9rem;
}

.required {
    color: var(--danger);
}

.optional {
    color: var(--text-muted);
    font-weight: normal;
}

.form-control {
    width: 100%;
    padding: 0.5rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: 6px;
    font-size: 0.9rem;
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.form-control:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.form-control.mono {
    font-family: monospace;
    font-size: 0.85rem;
}

select.form-control {
    padding-right: 2rem;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2394a3b8' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 0.75rem center;
    background-size: 12px;
}

.form-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
}

.form-help {
    display: block;
    margin-top: 0.25rem;
    font-size: 0.8rem;
    color: var(--text-muted);
}

.form-help code {
    background: var(--bg-tertiary);
    padding: 0.1rem 0.3rem;
    border-radius: 3px;
    font-size: 0.75rem;
}

.checkbox-label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    font-weight: normal;
}

.checkbox-label input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
}

.form-actions {
    display: flex;
    gap: 1rem;
    padding-top: 0.5rem;
}

.regex-builder-section {
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 1rem;
}

.regex-input {
    background: var(--bg-secondary) !important;
    border: 2px solid var(--border) !important;
    padding: 0.6rem 0.75rem !important;
    font-size: 0.9rem;
}

.regex-input:focus {
    border-color: var(--primary) !important;
    outline: none;
    box-shadow: 0 0 0 2px rgba(var(--primary-rgb), 0.2);
}

.regex-input::placeholder {
    color: var(--text-muted);
    opacity: 0.7;
}

/* Collapsible sections */
.collapsible-header {
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.collapsible-header:hover {
    color: var(--primary);
}

.collapse-arrow {
    font-size: 0.8rem;
    transition: transform 0.2s;
}

.collapsible-content {
    margin-top: 1rem;
}

/* Subsections within collapsible */
.subsection {
    padding: 1rem 0;
    border-bottom: 1px solid var(--border);
}

.subsection:last-child {
    border-bottom: none;
    padding-bottom: 0;
}

.subsection:first-child {
    padding-top: 0;
}

.subsection-header {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-primary);
    margin: 0 0 0.5rem 0;
}

/* Regex field with enable checkbox */
.regex-field-group {
    margin-bottom: 0.75rem;
}

.regex-field-header {
    margin-bottom: 0.25rem;
}

.disabled-field {
    opacity: 0.5;
    background: var(--bg-tertiary) !important;
}

.test-results-list {
    font-size: 0.75rem;
    max-height: 250px;
    overflow-y: auto;
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0.5rem;
    background: var(--bg-tertiary);
}

.test-result-item {
    margin-bottom: 0.5rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--border);
}

.test-result-item:last-child {
    margin-bottom: 0;
    padding-bottom: 0;
    border-bottom: none;
}

.stream-name-scroll {
    overflow-x: auto;
    white-space: nowrap;
    flex: 1;
    padding: 2px 0;
}

.stream-name-scroll code {
    font-size: 0.7rem;
}

.test-result-detail {
    margin-left: 1rem;
    margin-top: 0.25rem;
    color: var(--text-muted);
    font-size: 0.7rem;
}

@media (max-width: 768px) {
    .form-row {
        grid-template-columns: 1fr;
    }
}

/* Multi-Sport Leagues Picker */
.leagues-picker-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 1rem;
}

.leagues-sport-group {
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0.75rem;
}

.leagues-sport-header {
    font-weight: 600;
    margin-bottom: 0.5rem;
    padding-bottom: 0.25rem;
    border-bottom: 1px solid var(--border);
    font-size: 0.85rem;
    color: var(--text-primary);
}

.leagues-list {
    display: flex;
    flex-direction: column;
    gap: 0.375rem;
}

.league-checkbox {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    font-size: 0.8125rem;
    color: var(--text-secondary);
}

.league-checkbox:hover {
    color: var(--text-primary);
}

.league-checkbox input[type="checkbox"] {
    width: 14px;
    height: 14px;
    accent-color: var(--primary);
}

.badge-info {
    background: var(--info);
    color: white;
    padding: 0.1rem 0.4rem;
    border-radius: 4px;
    font-weight: 600;
}

/* Multi-Sport Panel - use tertiary (lighter in dark mode) for nested panel */
.multi-sport-panel {
    margin-top: 1rem;
    padding: 1rem;
    background: var(--bg-tertiary);
    border-radius: 6px;
    border: 1px solid var(--border);
}

/* Form controls inside panel use secondary (darker) for contrast */
.multi-sport-panel .form-control {
    background: var(--bg-secondary);
}

/* Leagues picker groups inside panel - use secondary for contrast */
.multi-sport-panel .leagues-sport-group {
    background: var(--bg-secondary);
}
</style>
{% endblock %}
