{% extends "base.html" %}

{% block title %}{% if mode == 'add' %}Add{% else %}Edit{% endif %} Event Group - Teamarr{% endblock %}

{% block content %}
<div class="form-container">
    <div class="page-header">
        <div style="margin-bottom: 0.75rem;">
            {% if mode == 'add' %}
            <a href="{{ url_for('event_groups_import') }}" class="btn btn-sm btn-secondary">&larr; Back to Import</a>
            {% else %}
            <a href="{{ url_for('event_groups_list') }}" class="btn btn-sm btn-secondary">&larr; Back to Event Groups</a>
            {% endif %}
        </div>
        <h1>{% if mode == 'add' %}Add Event Group{% else %}Edit Event Group{% endif %}</h1>
        {% if mode == 'edit' %}
            <p class="page-subtitle">{{ group.group_name }}</p>
        {% endif %}
    </div>

    <form id="event-group-form" method="POST">
        <!-- Group Info Section -->
        <div class="form-section">
            {% if mode == 'edit' %}
                <!-- Read-only group info for edit mode -->
                <div class="group-info-display">
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <div style="background: var(--primary); color: white; width: 48px; height: 48px; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-weight: 600;">
                            {{ group.assigned_league[:3].upper() }}
                        </div>
                        <div>
                            <h3 style="margin: 0;">{{ group.group_name }}</h3>
                            <p class="text-muted" style="margin: 0.25rem 0 0 0;">
                                {{ group.assigned_sport | title }} &bull; {{ group.assigned_league.upper() }}
                                {% if group.account_name %}&bull; {{ group.account_name }}{% endif %}
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Hidden fields for edit mode -->
                <input type="hidden" name="group_id" value="{{ group.id }}">
            {% else %}
                <!-- Add mode: sport/league selection -->
                <input type="hidden" name="dispatcharr_group_id" value="{{ dispatcharr_group_id }}">
                <input type="hidden" name="dispatcharr_account_id" value="{{ dispatcharr_account_id }}">
                <input type="hidden" name="group_name" value="{{ group_name }}">
                <input type="hidden" name="account_name" value="{{ account_name }}">

                <div class="group-info-display">
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <div style="background: var(--bg-tertiary); border: 2px dashed var(--border); width: 48px; height: 48px; border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                            <span style="color: var(--text-muted);">?</span>
                        </div>
                        <div>
                            <h3 style="margin: 0;">{{ group_name }}</h3>
                            <p class="text-muted" style="margin: 0.25rem 0 0 0;">
                                {% if account_name %}{{ account_name }}{% else %}New event group{% endif %}
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Parent Group Selection - FIRST before sport/league -->
                <div class="form-group" style="margin-top: 1rem;">
                    <label for="parent_group_id">Group Type</label>
                    <select id="parent_group_id" name="parent_group_id" class="form-control" onchange="handleParentGroupChange()">
                        <option value="">Independent Group (creates its own channels)</option>
                    </select>
                    <small class="form-help">Child groups add streams to their parent's channels instead of creating new ones.</small>
                </div>

                <!-- Child Group Notice - shown when parent selected -->
                <div id="child-group-notice" class="child-group-notice" style="display: none;">
                    <div class="notice-icon">↳</div>
                    <div class="notice-content">
                        <strong>Child Group Mode</strong>
                        <p>This group will add its matched streams to the parent group's channels. Sport, league, template and channel settings are inherited from the parent. Custom regex settings remain available to match your provider's stream names.</p>
                    </div>
                </div>

                <div class="form-row" id="sport-league-row">
                    <div class="form-group">
                        <label for="assigned_sport">Sport <span class="required" id="sport-required">*</span></label>
                        <select id="assigned_sport" name="assigned_sport" class="form-control" onchange="updateLeagueOptions()" required>
                            <option value="">Loading sports...</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="assigned_league">League <span class="required" id="league-required">*</span></label>
                        <select id="assigned_league" name="assigned_league" class="form-control" required>
                            <option value="">Select sport first...</option>
                        </select>
                    </div>
                </div>
            {% endif %}

            {% if mode == 'edit' %}
            <!-- Parent Group Selection for edit mode -->
            <div class="form-group" style="margin-top: 1rem;">
                <label for="parent_group_id">Group Type</label>
                <select id="parent_group_id" name="parent_group_id" class="form-control" onchange="handleParentGroupChange()">
                    <option value="">Independent Group (creates its own channels)</option>
                </select>
                <small class="form-help">Child groups add streams to their parent's channels instead of creating new ones.</small>
            </div>

            <!-- Child Group Notice - shown when parent selected -->
            <div id="child-group-notice" class="child-group-notice" style="display: none;">
                <div class="notice-icon">↳</div>
                <div class="notice-content">
                    <strong>Child Group Mode</strong>
                    <p>This group inherits template and channel settings from its parent. Only custom regex settings are editable below.</p>
                </div>
            </div>
            {% endif %}
        </div>

        <!-- Independent Group Settings (hidden for child groups) -->
        <div id="independent-settings">
            <div class="form-section">
                <h2>Template & Channel Settings</h2>

                <div class="form-group">
                    <label for="event_template_id">Event Template <span class="required">*</span></label>
                    <select id="event_template_id" name="event_template_id" class="form-control" required>
                        <option value="" disabled>Select a template...</option>
                        {% for template in event_templates %}
                        <option value="{{ template.id }}" {% if group and group.event_template_id == template.id %}selected{% endif %}>
                            {{ template.name }}
                        </option>
                        {% endfor %}
                    </select>
                    <small class="form-help">Required. Controls EPG title, description, and channel naming.</small>
                </div>

                <div class="form-group">
                <label for="channel_start">Channel Start Number</label>
                <input type="number" id="channel_start" name="channel_start" class="form-control"
                       placeholder="Auto-calculated if empty" min="1" max="9999"
                       value="{{ group.channel_start if group and group.channel_start else '' }}">
                <small class="form-help">First channel number for created channels (max 9999). Leave empty to auto-assign next available range.</small>
            </div>

            <div class="form-group">
                <label for="channel_group_id">Channel Group</label>
                <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;">
                    <input type="text" id="group-filter" class="form-control" placeholder="Filter groups..." style="flex: 1;" oninput="filterChannelGroups()">
                    <button type="button" class="btn btn-sm btn-secondary" onclick="toggleCreateGroupForm()">+ New</button>
                </div>
                <div id="create-group-form" style="display: none; margin-bottom: 0.5rem; padding: 0.5rem; background: var(--bg-tertiary); border-radius: 4px;">
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="text" id="new-group-name" class="form-control" placeholder="New group name..." style="flex: 1;">
                        <button type="button" class="btn btn-sm btn-success" onclick="createGroupInline()">Create</button>
                        <button type="button" class="btn btn-sm btn-secondary" onclick="toggleCreateGroupForm()">Cancel</button>
                    </div>
                    <div id="create-group-status" style="margin-top: 0.25rem; font-size: 0.75rem;"></div>
                </div>
                <select id="channel_group_id" name="channel_group_id" class="form-control" size="5" style="height: auto;">
                    <option value="">Loading groups...</option>
                </select>
                <small class="form-help">Dispatcharr group to assign created channels to. Only non-M3U groups shown.</small>
            </div>

            <div class="form-group">
                <label for="stream_profile_id">Stream Profile</label>
                <div style="margin-bottom: 0.5rem;">
                    <input type="text" id="profile-filter" class="form-control" placeholder="Filter profiles..." oninput="filterStreamProfiles()">
                </div>
                <select id="stream_profile_id" name="stream_profile_id" class="form-control" size="4" style="height: auto;">
                    <option value="">Loading profiles...</option>
                </select>
                <small class="form-help">Leave blank to use default.</small>
            </div>

            <div class="form-group">
                <label for="channel_profile_ids">Channel Profiles</label>
                <div style="margin-bottom: 0.5rem; display: flex; gap: 0.5rem;">
                    <input type="text" id="channel-profile-filter" class="form-control" placeholder="Filter profiles..." oninput="filterChannelProfiles()" style="flex: 1;">
                    <button type="button" class="btn btn-secondary btn-sm" onclick="clearChannelProfiles()" title="Clear selection">Clear</button>
                    <button type="button" class="btn btn-sm btn-secondary" onclick="toggleCreateChannelProfileForm()">+ New</button>
                </div>
                <div id="create-channel-profile-form" style="display: none; margin-bottom: 0.5rem; padding: 0.5rem; background: var(--bg-tertiary); border-radius: 4px;">
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="text" id="new-channel-profile-name" class="form-control" placeholder="New profile name..." style="flex: 1;">
                        <button type="button" class="btn btn-sm btn-success" onclick="createChannelProfileInline()">Create</button>
                        <button type="button" class="btn btn-sm btn-secondary" onclick="toggleCreateChannelProfileForm()">Cancel</button>
                    </div>
                    <div id="create-channel-profile-status" style="margin-top: 0.25rem; font-size: 0.75rem;"></div>
                </div>
                <select id="channel_profile_ids" name="channel_profile_ids" class="form-control" size="4" style="height: auto;" multiple>
                    <option value="">Loading profiles...</option>
                </select>
                <small class="form-help">Ctrl/Cmd+click to select multiple. Use Clear button to deselect all.</small>
                </div>
            </div>
        </div><!-- end independent-settings -->

        <!-- Custom Regex Section (Collapsible) - Available for both parent and child groups -->
        <div class="form-section collapsible-section">
            <h2 class="collapsible-header" onclick="toggleSection('custom-regex')">
                <span class="collapse-arrow" id="custom-regex-arrow">▶</span>
                Custom Regex
            </h2>
            <div id="custom-regex-content" class="collapsible-content" style="display: none;">

                <!-- Stream Filtering Subsection -->
                <div class="subsection">
                    <h3 class="subsection-header">Stream Filtering</h3>
                    <p class="section-description">Streams are automatically filtered to only include game streams (those with vs, @, or at).</p>

                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="skip_builtin_filter" name="skip_builtin_filter"
                                   {% if group and group.skip_builtin_filter %}checked{% endif %}>
                            <span>Skip built-in game detection</span>
                        </label>
                        <small class="form-help">Disable automatic filtering when stream names don't use standard separators (vs, @, at).</small>
                    </div>

                    <div class="form-group regex-field-group">
                        <div class="regex-field-header">
                            <label class="checkbox-label">
                                <input type="checkbox" id="stream_exclude_regex_enabled" name="stream_exclude_regex_enabled"
                                       {% if group and group.stream_exclude_regex_enabled %}checked{% endif %}
                                       onchange="toggleRegexField('stream_exclude_regex')">
                                <span>Exclusion Pattern</span>
                            </label>
                        </div>
                        <input type="text" id="stream_exclude_regex" name="stream_exclude_regex"
                               class="form-control mono regex-input {% if not group or not group.stream_exclude_regex_enabled %}disabled-field{% endif %}"
                               placeholder="e.g., \(ES\)|\(ALT\)|All.?Star"
                               value="{{ group.stream_exclude_regex if group and group.stream_exclude_regex else '' }}"
                               {% if not group or not group.stream_exclude_regex_enabled %}disabled{% endif %}>
                    </div>
                </div>

                <!-- Custom Team Matching Subsection -->
                <div class="subsection">
                    <h3 class="subsection-header">Team Matching</h3>
                    <p class="section-description">Override built-in matching with custom regex patterns. Enable individual fields as needed.</p>

                    <div class="form-group regex-field-group">
                        <div class="regex-field-header">
                            <label class="checkbox-label">
                                <input type="checkbox" id="custom_regex_teams_enabled" name="custom_regex_teams_enabled"
                                       {% if group and group.custom_regex_teams_enabled %}checked{% endif %}
                                       onchange="toggleRegexField('custom_regex_teams')">
                                <span>Teams Pattern</span>
                            </label>
                        </div>
                        <input type="text" id="custom_regex_teams" name="custom_regex_teams"
                               class="form-control mono regex-input {% if not group or not group.custom_regex_teams_enabled %}disabled-field{% endif %}"
                               placeholder="(?P<team1>[A-Z]{2,3})\s*[@vs]+\s*(?P<team2>[A-Z]{2,3})"
                               value="{{ group.custom_regex_teams if group and group.custom_regex_teams else '' }}"
                               {% if not group or not group.custom_regex_teams_enabled %}disabled{% endif %}>
                    </div>

                    <div class="form-row">
                        <div class="form-group regex-field-group">
                            <div class="regex-field-header">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="custom_regex_date_enabled" name="custom_regex_date_enabled"
                                           {% if group and group.custom_regex_date_enabled %}checked{% endif %}
                                           onchange="toggleRegexField('custom_regex_date')">
                                    <span>Date Pattern</span>
                                </label>
                            </div>
                            <input type="text" id="custom_regex_date" name="custom_regex_date"
                                   class="form-control mono regex-input {% if not group or not group.custom_regex_date_enabled %}disabled-field{% endif %}"
                                   placeholder="(?P<date>\d{1,2}/\d{1,2})"
                                   value="{{ group.custom_regex_date if group and group.custom_regex_date else '' }}"
                                   {% if not group or not group.custom_regex_date_enabled %}disabled{% endif %}>
                        </div>

                        <div class="form-group regex-field-group">
                            <div class="regex-field-header">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="custom_regex_time_enabled" name="custom_regex_time_enabled"
                                           {% if group and group.custom_regex_time_enabled %}checked{% endif %}
                                           onchange="toggleRegexField('custom_regex_time')">
                                    <span>Time Pattern</span>
                                </label>
                            </div>
                            <input type="text" id="custom_regex_time" name="custom_regex_time"
                                   class="form-control mono regex-input {% if not group or not group.custom_regex_time_enabled %}disabled-field{% endif %}"
                                   placeholder="(?P<time>\d{1,2}:\d{2}\s*(?:AM|PM)?)"
                                   value="{{ group.custom_regex_time if group and group.custom_regex_time else '' }}"
                                   {% if not group or not group.custom_regex_time_enabled %}disabled{% endif %}>
                        </div>
                    </div>

                    {% if mode == 'edit' %}
                    <div class="form-group">
                        <button type="button" class="btn btn-secondary" onclick="testRegexPatterns()" id="test-regex-btn">
                            Test Patterns
                        </button>
                        <div id="regex-test-results" style="margin-top: 0.75rem;"></div>
                    </div>
                    {% endif %}
                </div>
            </div>
        </div>

        <!-- Form Actions -->
        <div class="form-actions">
            <button type="submit" class="btn btn-primary">
                {% if mode == 'add' %}Add Event Group{% else %}Save Changes{% endif %}
            </button>
            <a href="{{ url_for('event_groups_list') }}" class="btn btn-secondary">Cancel</a>
        </div>
    </form>
</div>

<script>
// Channel groups data
let channelGroups = [];
let allChannelGroups = [];

// Stream profiles data
let streamProfiles = [];
let allStreamProfiles = [];

// Channel profiles data
let channelProfiles = [];

// Event groups for parent selection
let eventGroups = [];

// Initialize on page load
document.addEventListener('DOMContentLoaded', async function() {
    await Promise.all([loadLeagues(), loadChannelGroups(), loadStreamProfiles(), loadChannelProfiles(), loadEventGroups()]);
    {% if mode == 'edit' and group.channel_group_id %}
    document.getElementById('channel_group_id').value = '{{ group.channel_group_id }}';
    {% endif %}
    {% if mode == 'edit' and group.stream_profile_id %}
    document.getElementById('stream_profile_id').value = '{{ group.stream_profile_id }}';
    {% endif %}
    {% if mode == 'edit' and group.channel_profile_ids %}
    // Set selected channel profiles (multiselect)
    const profileIds = {{ group.channel_profile_ids | safe }};
    const profileSelect = document.getElementById('channel_profile_ids');
    profileIds.forEach(id => {
        const option = profileSelect.querySelector(`option[value="${id}"]`);
        if (option) option.selected = true;
    });
    {% endif %}
    {% if mode == 'edit' and group.parent_group_id %}
    document.getElementById('parent_group_id').value = '{{ group.parent_group_id }}';
    handleParentGroupChange();  // Update UI based on parent selection
    {% endif %}
});

// League options loaded from database
let leaguesBySport = {};

async function loadLeagues() {
    try {
        const response = await fetch('/api/leagues');
        const data = await response.json();

        if (data.leagues) {
            // Group leagues by sport
            leaguesBySport = {};
            data.leagues.forEach(league => {
                if (!leaguesBySport[league.sport]) {
                    leaguesBySport[league.sport] = [];
                }
                leaguesBySport[league.sport].push({
                    value: league.code,
                    label: league.name
                });
            });

            // Update sport dropdown with available sports
            const sportSelect = document.getElementById('assigned_sport');
            if (sportSelect) {
                const currentValue = sportSelect.value;
                sportSelect.innerHTML = '<option value="">Select sport...</option>';
                Object.keys(leaguesBySport).sort().forEach(sport => {
                    const option = document.createElement('option');
                    option.value = sport;
                    option.textContent = sport.charAt(0).toUpperCase() + sport.slice(1);
                    sportSelect.appendChild(option);
                });
                if (currentValue) sportSelect.value = currentValue;
            }
        }
    } catch (error) {
        console.error('Error loading leagues:', error);
    }
}

function updateLeagueOptions() {
    const sport = document.getElementById('assigned_sport').value;
    const leagueSelect = document.getElementById('assigned_league');

    leagueSelect.innerHTML = '<option value="">Select league...</option>';

    if (sport && leaguesBySport[sport]) {
        leaguesBySport[sport].forEach(league => {
            const option = document.createElement('option');
            option.value = league.value;
            option.textContent = league.label;
            leagueSelect.appendChild(option);
        });
    }
}

async function loadChannelGroups() {
    try {
        const response = await fetch('/api/dispatcharr/channel-groups?exclude_m3u=true');
        const data = await response.json();

        if (response.ok && data.groups) {
            allChannelGroups = data.groups || [];
            channelGroups = [...allChannelGroups];
            renderChannelGroups();
        } else {
            console.error('Failed to load channel groups:', data.error);
            document.getElementById('channel_group_id').innerHTML = '<option value="">(Failed to load groups)</option>';
        }
    } catch (error) {
        console.error('Error loading channel groups:', error);
        document.getElementById('channel_group_id').innerHTML = '<option value="">(Error loading groups)</option>';
    }
}

function renderChannelGroups() {
    const select = document.getElementById('channel_group_id');
    const currentValue = select.value;

    select.innerHTML = '<option value="">&lt;No group assignment&gt;</option>';

    channelGroups.forEach(group => {
        const option = document.createElement('option');
        option.value = group.id;
        option.textContent = group.name;
        select.appendChild(option);
    });

    if (currentValue) {
        select.value = currentValue;
    }
}

function filterChannelGroups() {
    const filter = document.getElementById('group-filter').value.toLowerCase();

    if (!filter) {
        channelGroups = [...allChannelGroups];
    } else {
        channelGroups = allChannelGroups.filter(g =>
            g.name.toLowerCase().includes(filter)
        );
    }

    renderChannelGroups();
}

function toggleCreateGroupForm() {
    const form = document.getElementById('create-group-form');
    form.style.display = form.style.display === 'none' ? 'block' : 'none';
    if (form.style.display === 'block') {
        document.getElementById('new-group-name').focus();
    }
}

async function createGroupInline() {
    const name = document.getElementById('new-group-name').value.trim();
    const statusDiv = document.getElementById('create-group-status');

    if (!name) {
        statusDiv.innerHTML = '<span style="color: var(--danger);">Please enter a group name</span>';
        return;
    }

    statusDiv.innerHTML = '<span style="color: var(--text-muted);">Creating...</span>';

    try {
        const response = await fetch('/api/dispatcharr/channel-groups', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: name })
        });

        const data = await response.json();

        if (data.success) {
            statusDiv.innerHTML = '<span style="color: var(--success);">Created!</span>';
            document.getElementById('new-group-name').value = '';

            // Reload groups and select the new one
            await loadChannelGroups();
            document.getElementById('channel_group_id').value = data.group.id;

            setTimeout(() => {
                toggleCreateGroupForm();
            }, 500);
        } else {
            statusDiv.innerHTML = `<span style="color: var(--danger);">${data.error || 'Failed to create group'}</span>`;
        }
    } catch (error) {
        statusDiv.innerHTML = `<span style="color: var(--danger);">Error: ${error.message}</span>`;
    }
}

function toggleSection(sectionId) {
    const content = document.getElementById(sectionId + '-content');
    const arrow = document.getElementById(sectionId + '-arrow');

    if (content.style.display === 'none') {
        content.style.display = 'block';
        arrow.textContent = '▼';
    } else {
        content.style.display = 'none';
        arrow.textContent = '▶';
    }
}

function toggleRegexField(fieldId) {
    const checkbox = document.getElementById(fieldId + '_enabled');
    const input = document.getElementById(fieldId);

    if (checkbox.checked) {
        input.disabled = false;
        input.classList.remove('disabled-field');
    } else {
        input.disabled = true;
        input.classList.add('disabled-field');
    }
}

// ============================================================================
// Stream Profiles
// ============================================================================

async function loadStreamProfiles() {
    try {
        const response = await fetch('/api/dispatcharr/stream-profiles');
        const data = await response.json();

        if (response.ok && data.profiles) {
            allStreamProfiles = data.profiles || [];
            streamProfiles = [...allStreamProfiles];
            renderStreamProfiles();
        } else {
            console.error('Failed to load stream profiles:', data.error);
            document.getElementById('stream_profile_id').innerHTML = '<option value="">(Failed to load profiles)</option>';
        }
    } catch (error) {
        console.error('Error loading stream profiles:', error);
        document.getElementById('stream_profile_id').innerHTML = '<option value="">(Error loading profiles)</option>';
    }
}

function renderStreamProfiles() {
    const select = document.getElementById('stream_profile_id');
    const currentValue = select.value;

    select.innerHTML = '';

    streamProfiles.forEach(profile => {
        const option = document.createElement('option');
        option.value = profile.id;
        const activeIndicator = profile.is_active ? '' : ' (inactive)';
        option.textContent = profile.name + activeIndicator;
        select.appendChild(option);
    });

    if (currentValue) {
        select.value = currentValue;
    }
}

function filterStreamProfiles() {
    const filter = document.getElementById('profile-filter').value.toLowerCase();

    if (!filter) {
        streamProfiles = [...allStreamProfiles];
    } else {
        streamProfiles = allStreamProfiles.filter(p =>
            p.name.toLowerCase().includes(filter)
        );
    }

    renderStreamProfiles();
}

async function loadChannelProfiles() {
    try {
        const response = await fetch('/api/dispatcharr/channel-profiles');
        const data = await response.json();

        if (response.ok && data.profiles) {
            channelProfiles = data.profiles || [];
            renderChannelProfiles();
        } else {
            console.error('Failed to load channel profiles:', data.error);
            document.getElementById('channel_profile_ids').innerHTML = '<option value="">(Failed to load profiles)</option>';
        }
    } catch (error) {
        console.error('Error loading channel profiles:', error);
        document.getElementById('channel_profile_ids').innerHTML = '<option value="">(Error loading profiles)</option>';
    }
}

function renderChannelProfiles() {
    const select = document.getElementById('channel_profile_ids');
    // Get currently selected values (multiselect)
    const selectedValues = Array.from(select.selectedOptions).map(o => o.value);

    select.innerHTML = '';

    channelProfiles.forEach(profile => {
        const option = document.createElement('option');
        option.value = profile.id;
        option.textContent = profile.name;
        // Restore selection state
        if (selectedValues.includes(String(profile.id))) {
            option.selected = true;
        }
        select.appendChild(option);
    });
}

function filterChannelProfiles() {
    const filter = document.getElementById('channel-profile-filter').value.toLowerCase();
    const select = document.getElementById('channel_profile_ids');
    // Get currently selected values (multiselect)
    const selectedValues = Array.from(select.selectedOptions).map(o => o.value);

    select.innerHTML = '';

    channelProfiles.forEach(profile => {
        if (profile.name.toLowerCase().includes(filter)) {
            const option = document.createElement('option');
            option.value = profile.id;
            option.textContent = profile.name;
            // Restore selection state
            if (selectedValues.includes(String(profile.id))) {
                option.selected = true;
            }
            select.appendChild(option);
        }
    });
}

function clearChannelProfiles() {
    const select = document.getElementById('channel_profile_ids');
    Array.from(select.options).forEach(opt => opt.selected = false);
}

function toggleCreateChannelProfileForm() {
    const form = document.getElementById('create-channel-profile-form');
    form.style.display = form.style.display === 'none' ? 'block' : 'none';
    if (form.style.display === 'block') {
        document.getElementById('new-channel-profile-name').focus();
    }
}

async function createChannelProfileInline() {
    const name = document.getElementById('new-channel-profile-name').value.trim();
    const statusDiv = document.getElementById('create-channel-profile-status');

    if (!name) {
        statusDiv.innerHTML = '<span style="color: var(--danger);">Please enter a profile name</span>';
        return;
    }

    statusDiv.innerHTML = '<span style="color: var(--text-muted);">Creating...</span>';

    try {
        const response = await fetch('/api/dispatcharr/channel-profiles', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: name })
        });

        const data = await response.json();

        if (data.success) {
            statusDiv.innerHTML = '<span style="color: var(--success);">Created!</span>';
            document.getElementById('new-channel-profile-name').value = '';

            // Reload profiles and select the new one
            await loadChannelProfiles();
            const profileSelect = document.getElementById('channel_profile_ids');
            const newOption = profileSelect.querySelector(`option[value="${data.profile_id}"]`);
            if (newOption) newOption.selected = true;

            setTimeout(() => {
                toggleCreateChannelProfileForm();
            }, 500);
        } else {
            statusDiv.innerHTML = `<span style="color: var(--danger);">${data.error || 'Failed to create profile'}</span>`;
        }
    } catch (error) {
        statusDiv.innerHTML = `<span style="color: var(--danger);">Error: ${error.message}</span>`;
    }
}

// ============================================================================
// Event Groups (for parent selection)
// ============================================================================

async function loadEventGroups() {
    try {
        const response = await fetch('/api/event-epg/groups');
        const data = await response.json();

        if (response.ok && data.groups) {
            eventGroups = data.groups || [];
            renderEventGroups();
        } else {
            console.error('Failed to load event groups:', data.error);
        }
    } catch (error) {
        console.error('Error loading event groups:', error);
    }
}

function renderEventGroups() {
    const select = document.getElementById('parent_group_id');
    const currentValue = select.value;

    // Keep the "None" option
    select.innerHTML = '<option value="">Independent Group (creates its own channels)</option>';

    {% if mode == 'edit' %}
    const currentGroupId = {{ group.id }};
    {% else %}
    const currentGroupId = null;
    {% endif %}

    // Add a separator if there are parent groups available
    let hasParentOptions = false;
    eventGroups.forEach(group => {
        if (currentGroupId && group.id === currentGroupId) return;
        if (group.parent_group_id) return;
        hasParentOptions = true;
    });

    if (hasParentOptions) {
        const separator = document.createElement('option');
        separator.disabled = true;
        separator.textContent = '── Child of: ──';
        select.appendChild(separator);
    }

    eventGroups.forEach(group => {
        // Don't show current group as potential parent (avoid circular reference)
        if (currentGroupId && group.id === currentGroupId) {
            return;
        }
        // Don't show groups that are already children (no multi-level nesting)
        if (group.parent_group_id) {
            return;
        }

        const option = document.createElement('option');
        option.value = group.id;
        option.textContent = `↳ ${group.group_name} (${group.assigned_league.toUpperCase()})`;
        select.appendChild(option);
    });

    if (currentValue) {
        select.value = currentValue;
    }

    // Trigger UI update based on current value
    handleParentGroupChange();
}

function handleParentGroupChange() {
    const parentSelect = document.getElementById('parent_group_id');
    const isChildGroup = parentSelect.value !== '';

    const notice = document.getElementById('child-group-notice');
    const independentSettings = document.getElementById('independent-settings');
    const templateSelect = document.getElementById('event_template_id');

    // Sport/league elements (only exist in add mode)
    const sportSelect = document.getElementById('assigned_sport');
    const leagueSelect = document.getElementById('assigned_league');
    const sportLeagueRow = document.getElementById('sport-league-row');
    const sportRequired = document.getElementById('sport-required');
    const leagueRequired = document.getElementById('league-required');

    if (isChildGroup) {
        // Show child notice, hide independent settings
        notice.style.display = 'flex';
        independentSettings.classList.add('hidden');
        // Template not required for child groups
        templateSelect.removeAttribute('required');

        // Auto-expand the regex section for child groups (it's the only thing they can edit)
        const regexContent = document.getElementById('custom-regex-content');
        const regexArrow = document.getElementById('custom-regex-arrow');
        if (regexContent && regexContent.style.display === 'none') {
            regexContent.style.display = 'block';
            if (regexArrow) regexArrow.textContent = '▼';
        }

        // In add mode: populate and disable sport/league from parent
        if (sportSelect && leagueSelect) {
            const parentId = parseInt(parentSelect.value);
            const parentGroup = eventGroups.find(g => g.id === parentId);

            if (parentGroup) {
                // Set sport and trigger league population
                sportSelect.value = parentGroup.assigned_sport;
                sportSelect.disabled = true;
                sportSelect.removeAttribute('required');  // Backend inherits from parent
                updateLeagueOptions();

                // Set league after options are populated
                setTimeout(() => {
                    leagueSelect.value = parentGroup.assigned_league;
                    leagueSelect.disabled = true;
                    leagueSelect.removeAttribute('required');  // Backend inherits from parent
                }, 50);

                // Hide required asterisks (values enforced from parent)
                if (sportRequired) sportRequired.style.display = 'none';
                if (leagueRequired) leagueRequired.style.display = 'none';

                // Grey out the row visually
                if (sportLeagueRow) sportLeagueRow.style.opacity = '0.6';
            }
        }
    } else {
        // Hide child notice, show independent settings
        notice.style.display = 'none';
        independentSettings.classList.remove('hidden');
        // Template required for independent groups
        templateSelect.setAttribute('required', 'required');

        // In add mode: re-enable sport/league selection
        if (sportSelect && leagueSelect) {
            sportSelect.disabled = false;
            sportSelect.setAttribute('required', 'required');
            leagueSelect.disabled = false;
            leagueSelect.setAttribute('required', 'required');

            // Show required asterisks
            if (sportRequired) sportRequired.style.display = 'inline';
            if (leagueRequired) leagueRequired.style.display = 'inline';

            // Remove grey out
            if (sportLeagueRow) sportLeagueRow.style.opacity = '1';
        }
    }
}

{% if mode == 'edit' %}
async function testRegexPatterns() {
    const teamsPattern = document.getElementById('custom_regex_teams').value.trim();
    const datePattern = document.getElementById('custom_regex_date').value.trim();
    const timePattern = document.getElementById('custom_regex_time').value.trim();
    const excludePattern = document.getElementById('stream_exclude_regex').value.trim();
    const resultsDiv = document.getElementById('regex-test-results');
    const testBtn = document.getElementById('test-regex-btn');

    if (!teamsPattern) {
        resultsDiv.innerHTML = '<span style="color: var(--warning);">Teams pattern is required.</span>';
        return;
    }

    // Validate that pattern has required named groups
    if (!teamsPattern.includes('(?P<team1>') || !teamsPattern.includes('(?P<team2>')) {
        resultsDiv.innerHTML = '<span style="color: var(--warning);">Pattern must include (?P&lt;team1&gt;...) and (?P&lt;team2&gt;...) groups.</span>';
        return;
    }

    testBtn.disabled = true;
    testBtn.textContent = 'Testing...';
    resultsDiv.innerHTML = '<span style="color: var(--text-muted);">Testing patterns against streams...</span>';

    try {
        const response = await fetch('/api/event-epg/groups/{{ group.id }}/test-regex', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                teams_pattern: teamsPattern,
                date_pattern: datePattern || null,
                time_pattern: timePattern || null,
                exclude_pattern: excludePattern || null
            })
        });

        const data = await response.json();

        if (!response.ok) {
            resultsDiv.innerHTML = `<span style="color: var(--danger);">Error: ${escapeHtml(data.error)}</span>`;
            return;
        }

        let html = '';
        const matched = data.matched || 0;
        const excluded = data.excluded || 0;
        const total = data.tested || 0;
        const testedAfterExclude = total - excluded;
        const percentage = testedAfterExclude > 0 ? Math.round((matched / testedAfterExclude) * 100) : 0;

        html = `<div style="margin-bottom: 0.5rem;">
            <strong>${matched}/${testedAfterExclude}</strong> streams matched (${percentage}%)`;
        if (excluded > 0) {
            html += ` · <span style="color: var(--warning);">${excluded} excluded</span>`;
        }
        html += `</div>`;

        if (data.results && data.results.length > 0) {
            html += '<div class="test-results-list">';
            data.results.forEach(result => {
                let icon, color;
                if (result.excluded) {
                    icon = '⊘';
                    color = 'var(--warning)';
                } else if (result.matched) {
                    icon = '✓';
                    color = 'var(--success)';
                } else {
                    icon = '✗';
                    color = 'var(--danger)';
                }
                html += `<div class="test-result-item">
                    <div style="color: ${color}; display: flex; align-items: center; gap: 0.25rem;">
                        <span>${icon}</span>
                        <div class="stream-name-scroll">
                            <code>${escapeHtml(result.stream_name)}</code>
                        </div>
                    </div>`;
                if (result.matched) {
                    html += `<div class="test-result-detail">
                        ${escapeHtml(result.raw_team1)} → ${escapeHtml(result.resolved_team1)}<br>
                        ${escapeHtml(result.raw_team2)} → ${escapeHtml(result.resolved_team2)}`;
                    if (result.game_date || result.game_time) {
                        html += `<br>Date/Time: ${result.game_date || '-'} ${result.game_time || '-'}`;
                    }
                    html += '</div>';
                } else if (result.error) {
                    html += `<div class="test-result-detail" style="color: ${result.excluded ? 'var(--warning)' : 'var(--danger)'};">${escapeHtml(result.error)}</div>`;
                }
                html += '</div>';
            });
            html += '</div>';
        }

        resultsDiv.innerHTML = html;
    } catch (error) {
        resultsDiv.innerHTML = `<span style="color: var(--danger);">Error: ${escapeHtml(error.message)}</span>`;
    } finally {
        testBtn.disabled = false;
        testBtn.textContent = 'Test Patterns';
    }
}
{% endif %}

function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Form submission
document.getElementById('event-group-form').addEventListener('submit', async function(e) {
    e.preventDefault();

    const formData = new FormData(this);
    const data = {};

    // Checkbox fields that need boolean handling
    const checkboxFields = [
        'skip_builtin_filter',
        'stream_exclude_regex_enabled',
        'custom_regex_teams_enabled',
        'custom_regex_date_enabled',
        'custom_regex_time_enabled',
        'custom_regex_enabled'  // Legacy - keep for backwards compat
    ];

    formData.forEach((value, key) => {
        // Skip channel_profile_ids - handled separately as multiselect
        if (key === 'channel_profile_ids') return;

        if (value !== '' && value !== null) {
            // Convert numeric fields
            if (['channel_start', 'channel_group_id', 'stream_profile_id', 'event_template_id', 'dispatcharr_group_id', 'dispatcharr_account_id', 'parent_group_id'].includes(key)) {
                data[key] = value ? parseInt(value) : null;
            } else if (checkboxFields.includes(key)) {
                data[key] = true;
            } else {
                data[key] = value;
            }
        }
    });

    // Handle unchecked checkboxes - set to false
    checkboxFields.forEach(field => {
        if (!formData.has(field)) {
            data[field] = false;
        }
    });

    // Handle channel_profile_ids multiselect
    const profileSelect = document.getElementById('channel_profile_ids');
    const selectedProfileIds = Array.from(profileSelect.selectedOptions)
        .map(o => parseInt(o.value))
        .filter(id => !isNaN(id));
    data.channel_profile_ids = selectedProfileIds.length > 0 ? selectedProfileIds : null;

    // Get channel_group_name from selected option text
    const channelGroupSelect = document.getElementById('channel_group_id');
    if (channelGroupSelect.value) {
        const selectedOption = channelGroupSelect.options[channelGroupSelect.selectedIndex];
        if (selectedOption) {
            data.channel_group_name = selectedOption.textContent.trim();
        }
    }

    {% if mode == 'edit' %}
    const url = '/api/event-epg/groups/{{ group.id }}';
    const method = 'PATCH';
    {% else %}
    const url = '/api/event-epg/groups';
    const method = 'POST';
    {% endif %}

    try {
        const response = await fetch(url, {
            method: method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });

        const result = await response.json();

        if (response.ok) {
            window.location.href = '{{ url_for("event_groups_list") }}';
        } else {
            alert('Error: ' + (result.error || 'Failed to save'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
});
</script>

<style>
.form-container {
    max-width: 900px;
    margin: 0 auto;
    padding: 2rem 0;
}

.page-header {
    margin-bottom: 2rem;
}

.page-header h1 {
    margin: 0 0 0.5rem 0;
    font-size: 2rem;
    color: var(--text-primary);
}

.page-subtitle {
    margin: 0;
    color: var(--text-muted);
    font-size: 1rem;
}

.form-section {
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
}

.form-section h2 {
    margin: 0 0 0.5rem 0;
    font-size: 1.1rem;
    color: var(--text-primary);
}

.section-description {
    color: var(--text-muted);
    font-size: 0.875rem;
    margin: 0 0 1.25rem 0;
}

.group-info-display {
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 1rem;
    margin-bottom: 1.25rem;
}

/* Child Group Notice */
.child-group-notice {
    display: flex;
    gap: 1rem;
    background: rgba(168, 85, 247, 0.1);
    border: 1px solid rgba(168, 85, 247, 0.3);
    border-radius: 8px;
    padding: 1rem;
    margin-top: 1rem;
}

.child-group-notice .notice-icon {
    font-size: 1.5rem;
    color: #a855f7;
    flex-shrink: 0;
}

.child-group-notice .notice-content strong {
    display: block;
    color: #c4b5fd;
    margin-bottom: 0.25rem;
}

.child-group-notice .notice-content p {
    margin: 0;
    font-size: 0.875rem;
    color: var(--text-muted);
}

.light-theme .child-group-notice {
    background: rgba(168, 85, 247, 0.08);
}

.light-theme .child-group-notice .notice-content strong {
    color: #7c3aed;
}

/* Independent settings hidden state */
#independent-settings.hidden {
    display: none;
}

.form-group {
    margin-bottom: 1.25rem;
}

.form-group:last-child {
    margin-bottom: 0;
}

.form-group label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: 500;
    color: var(--text-secondary);
    font-size: 0.9rem;
}

.required {
    color: var(--danger);
}

.optional {
    color: var(--text-muted);
    font-weight: normal;
}

.form-control {
    width: 100%;
    padding: 0.5rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: 6px;
    font-size: 0.9rem;
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.form-control:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.form-control.mono {
    font-family: monospace;
    font-size: 0.85rem;
}

select.form-control {
    padding-right: 2rem;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2394a3b8' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 0.75rem center;
    background-size: 12px;
}

.form-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
}

.form-help {
    display: block;
    margin-top: 0.25rem;
    font-size: 0.8rem;
    color: var(--text-muted);
}

.form-help code {
    background: var(--bg-tertiary);
    padding: 0.1rem 0.3rem;
    border-radius: 3px;
    font-size: 0.75rem;
}

.checkbox-label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    font-weight: normal;
}

.checkbox-label input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
}

.form-actions {
    display: flex;
    gap: 1rem;
    padding-top: 0.5rem;
}

.regex-builder-section {
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 1rem;
}

.regex-input {
    background: var(--bg-secondary) !important;
    border: 2px solid var(--border) !important;
    padding: 0.6rem 0.75rem !important;
    font-size: 0.9rem;
}

.regex-input:focus {
    border-color: var(--primary) !important;
    outline: none;
    box-shadow: 0 0 0 2px rgba(var(--primary-rgb), 0.2);
}

.regex-input::placeholder {
    color: var(--text-muted);
    opacity: 0.7;
}

/* Collapsible sections */
.collapsible-header {
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.collapsible-header:hover {
    color: var(--primary);
}

.collapse-arrow {
    font-size: 0.8rem;
    transition: transform 0.2s;
}

.collapsible-content {
    margin-top: 1rem;
}

/* Subsections within collapsible */
.subsection {
    padding: 1rem 0;
    border-bottom: 1px solid var(--border);
}

.subsection:last-child {
    border-bottom: none;
    padding-bottom: 0;
}

.subsection:first-child {
    padding-top: 0;
}

.subsection-header {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-primary);
    margin: 0 0 0.5rem 0;
}

/* Regex field with enable checkbox */
.regex-field-group {
    margin-bottom: 0.75rem;
}

.regex-field-header {
    margin-bottom: 0.25rem;
}

.disabled-field {
    opacity: 0.5;
    background: var(--bg-tertiary) !important;
}

.test-results-list {
    font-size: 0.75rem;
    max-height: 250px;
    overflow-y: auto;
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0.5rem;
    background: var(--bg-tertiary);
}

.test-result-item {
    margin-bottom: 0.5rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--border);
}

.test-result-item:last-child {
    margin-bottom: 0;
    padding-bottom: 0;
    border-bottom: none;
}

.stream-name-scroll {
    overflow-x: auto;
    white-space: nowrap;
    flex: 1;
    padding: 2px 0;
}

.stream-name-scroll code {
    font-size: 0.7rem;
}

.test-result-detail {
    margin-left: 1rem;
    margin-top: 0.25rem;
    color: var(--text-muted);
    font-size: 0.7rem;
}

@media (max-width: 768px) {
    .form-row {
        grid-template-columns: 1fr;
    }
}
</style>
{% endblock %}
