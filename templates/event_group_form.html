{% extends "base.html" %}

{% block title %}{% if mode == 'add' %}Add{% else %}Edit{% endif %} Event Group - Teamarr{% endblock %}

{% block content %}
<div class="form-container">
    <div class="page-header">
        <div style="margin-bottom: 0.75rem;">
            {% if mode == 'add' %}
            <a href="{{ url_for('event_groups_import') }}" class="btn btn-sm btn-secondary">&larr; Back to Import</a>
            {% else %}
            <a href="{{ url_for('event_groups_list') }}" class="btn btn-sm btn-secondary">&larr; Back to Event Groups</a>
            {% endif %}
        </div>
        <h1>{% if mode == 'add' %}Add Event Group{% else %}Edit Event Group{% endif %}</h1>
        {% if mode == 'edit' %}
            <p class="page-subtitle">{{ group.group_name }}</p>
        {% endif %}
    </div>

    <form id="event-group-form" method="POST">
        <!-- Group Info Section -->
        <div class="form-section">
            {% if mode == 'edit' %}
                <!-- Read-only group info for edit mode -->
                <div class="group-info-display">
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <div style="background: var(--primary); color: white; width: 48px; height: 48px; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-weight: 600;">
                            {{ group.assigned_league[:3].upper() }}
                        </div>
                        <div>
                            <h3 style="margin: 0;">{{ group.group_name }}</h3>
                            <p class="text-muted" style="margin: 0.25rem 0 0 0;">
                                {{ group.assigned_sport | title }} &bull; {{ group.assigned_league.upper() }}
                                {% if group.account_name %}&bull; {{ group.account_name }}{% endif %}
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Hidden fields for edit mode -->
                <input type="hidden" name="group_id" value="{{ group.id }}">
            {% else %}
                <!-- Add mode: sport/league selection -->
                <input type="hidden" name="dispatcharr_group_id" value="{{ dispatcharr_group_id }}">
                <input type="hidden" name="dispatcharr_account_id" value="{{ dispatcharr_account_id }}">
                <input type="hidden" name="group_name" value="{{ group_name }}">
                <input type="hidden" name="account_name" value="{{ account_name }}">

                <div class="group-info-display">
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <div style="background: var(--bg-tertiary); border: 2px dashed var(--border); width: 48px; height: 48px; border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                            <span style="color: var(--text-muted);">?</span>
                        </div>
                        <div>
                            <h3 style="margin: 0;">{{ group_name }}</h3>
                            <p class="text-muted" style="margin: 0.25rem 0 0 0;">
                                {% if account_name %}{{ account_name }}{% else %}New event group{% endif %}
                            </p>
                        </div>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="assigned_sport">Sport <span class="required">*</span></label>
                        <select id="assigned_sport" name="assigned_sport" class="form-control" onchange="updateLeagueOptions()" required>
                            <option value="">Select sport...</option>
                            <option value="football">Football</option>
                            <option value="basketball">Basketball</option>
                            <option value="baseball">Baseball</option>
                            <option value="hockey">Hockey</option>
                            <option value="soccer">Soccer</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="assigned_league">League <span class="required">*</span></label>
                        <select id="assigned_league" name="assigned_league" class="form-control" required>
                            <option value="">Select sport first...</option>
                        </select>
                    </div>
                </div>
            {% endif %}

            <div class="form-group">
                <label for="event_template_id">Event Template <span class="required">*</span></label>
                <select id="event_template_id" name="event_template_id" class="form-control" required>
                    <option value="" disabled>Select a template...</option>
                    {% for template in event_templates %}
                    <option value="{{ template.id }}" {% if group and group.event_template_id == template.id %}selected{% endif %}>
                        {{ template.name }}
                    </option>
                    {% endfor %}
                </select>
                <small class="form-help">Required. Controls EPG title, description, and channel naming.</small>
            </div>
        </div>

        <!-- Channel Settings Section -->
        <div class="form-section">
            <h2>Channel Settings</h2>

            <div class="form-group">
                <label for="channel_start">Channel Start Number</label>
                <input type="number" id="channel_start" name="channel_start" class="form-control"
                       placeholder="Auto-calculated if empty" min="1"
                       value="{{ group.channel_start if group and group.channel_start else '' }}">
                <small class="form-help">First channel number for created channels. Leave empty to auto-assign next available range.</small>
            </div>

            <div class="form-group">
                <label for="channel_group_id">Channel Group</label>
                <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;">
                    <input type="text" id="group-filter" class="form-control" placeholder="Filter groups..." style="flex: 1;" oninput="filterChannelGroups()">
                    <button type="button" class="btn btn-sm btn-secondary" onclick="toggleCreateGroupForm()">+ New</button>
                </div>
                <div id="create-group-form" style="display: none; margin-bottom: 0.5rem; padding: 0.5rem; background: var(--bg-tertiary); border-radius: 4px;">
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="text" id="new-group-name" class="form-control" placeholder="New group name..." style="flex: 1;">
                        <button type="button" class="btn btn-sm btn-success" onclick="createGroupInline()">Create</button>
                        <button type="button" class="btn btn-sm btn-secondary" onclick="toggleCreateGroupForm()">Cancel</button>
                    </div>
                    <div id="create-group-status" style="margin-top: 0.25rem; font-size: 0.75rem;"></div>
                </div>
                <select id="channel_group_id" name="channel_group_id" class="form-control" size="5" style="height: auto;">
                    <option value="">Loading groups...</option>
                </select>
                <small class="form-help">Dispatcharr group to assign created channels to. Only non-M3U groups shown.</small>
            </div>

            <div class="form-group">
                <label for="stream_profile_id">Stream Profile</label>
                <div style="margin-bottom: 0.5rem;">
                    <input type="text" id="profile-filter" class="form-control" placeholder="Filter profiles..." oninput="filterStreamProfiles()">
                </div>
                <select id="stream_profile_id" name="stream_profile_id" class="form-control" size="4" style="height: auto;">
                    <option value="">Loading profiles...</option>
                </select>
                <small class="form-help">Leave blank to use default.</small>
            </div>

            <div class="form-group">
                <label for="channel_profile_id">Channel Profile</label>
                <div style="margin-bottom: 0.5rem;">
                    <input type="text" id="channel-profile-filter" class="form-control" placeholder="Filter profiles..." oninput="filterChannelProfiles()">
                </div>
                <select id="channel_profile_id" name="channel_profile_id" class="form-control" size="4" style="height: auto;">
                    <option value="">Loading profiles...</option>
                </select>
                <small class="form-help">Add created channels to this profile. Leave blank to skip.</small>
            </div>
        </div>

        <!-- Custom Regex Section (Collapsible) -->
        <div class="form-section collapsible-section">
            <h2 class="collapsible-header" onclick="toggleSection('custom-regex')">
                <span class="collapse-arrow" id="custom-regex-arrow">▶</span>
                Custom Regex
            </h2>
            <div id="custom-regex-content" class="collapsible-content" style="display: none;">

                <!-- Stream Filtering Subsection -->
                <div class="subsection">
                    <h3 class="subsection-header">Stream Filtering</h3>
                    <p class="section-description">Streams are automatically filtered to only include game streams (those with vs, @, or at).</p>

                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="skip_builtin_filter" name="skip_builtin_filter"
                                   {% if group and group.skip_builtin_filter %}checked{% endif %}>
                            <span>Skip built-in game detection</span>
                        </label>
                        <small class="form-help">Disable automatic filtering when stream names don't use standard separators (vs, @, at).</small>
                    </div>

                    <div class="form-group regex-field-group">
                        <div class="regex-field-header">
                            <label class="checkbox-label">
                                <input type="checkbox" id="stream_exclude_regex_enabled" name="stream_exclude_regex_enabled"
                                       {% if group and group.stream_exclude_regex_enabled %}checked{% endif %}
                                       onchange="toggleRegexField('stream_exclude_regex')">
                                <span>Exclusion Pattern</span>
                            </label>
                        </div>
                        <input type="text" id="stream_exclude_regex" name="stream_exclude_regex"
                               class="form-control mono regex-input {% if not group or not group.stream_exclude_regex_enabled %}disabled-field{% endif %}"
                               placeholder="e.g., \(ES\)|\(ALT\)|All.?Star"
                               value="{{ group.stream_exclude_regex if group and group.stream_exclude_regex else '' }}"
                               {% if not group or not group.stream_exclude_regex_enabled %}disabled{% endif %}>
                    </div>
                </div>

                <!-- Custom Team Matching Subsection -->
                <div class="subsection">
                    <h3 class="subsection-header">Team Matching</h3>
                    <p class="section-description">Override built-in matching with custom regex patterns. Enable individual fields as needed.</p>

                    <div class="form-group regex-field-group">
                        <div class="regex-field-header">
                            <label class="checkbox-label">
                                <input type="checkbox" id="custom_regex_teams_enabled" name="custom_regex_teams_enabled"
                                       {% if group and group.custom_regex_teams_enabled %}checked{% endif %}
                                       onchange="toggleRegexField('custom_regex_teams')">
                                <span>Teams Pattern</span>
                            </label>
                        </div>
                        <input type="text" id="custom_regex_teams" name="custom_regex_teams"
                               class="form-control mono regex-input {% if not group or not group.custom_regex_teams_enabled %}disabled-field{% endif %}"
                               placeholder="(?P<team1>[A-Z]{2,3})\s*[@vs]+\s*(?P<team2>[A-Z]{2,3})"
                               value="{{ group.custom_regex_teams if group and group.custom_regex_teams else '' }}"
                               {% if not group or not group.custom_regex_teams_enabled %}disabled{% endif %}>
                    </div>

                    <div class="form-row">
                        <div class="form-group regex-field-group">
                            <div class="regex-field-header">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="custom_regex_date_enabled" name="custom_regex_date_enabled"
                                           {% if group and group.custom_regex_date_enabled %}checked{% endif %}
                                           onchange="toggleRegexField('custom_regex_date')">
                                    <span>Date Pattern</span>
                                </label>
                            </div>
                            <input type="text" id="custom_regex_date" name="custom_regex_date"
                                   class="form-control mono regex-input {% if not group or not group.custom_regex_date_enabled %}disabled-field{% endif %}"
                                   placeholder="(?P<date>\d{1,2}/\d{1,2})"
                                   value="{{ group.custom_regex_date if group and group.custom_regex_date else '' }}"
                                   {% if not group or not group.custom_regex_date_enabled %}disabled{% endif %}>
                        </div>

                        <div class="form-group regex-field-group">
                            <div class="regex-field-header">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="custom_regex_time_enabled" name="custom_regex_time_enabled"
                                           {% if group and group.custom_regex_time_enabled %}checked{% endif %}
                                           onchange="toggleRegexField('custom_regex_time')">
                                    <span>Time Pattern</span>
                                </label>
                            </div>
                            <input type="text" id="custom_regex_time" name="custom_regex_time"
                                   class="form-control mono regex-input {% if not group or not group.custom_regex_time_enabled %}disabled-field{% endif %}"
                                   placeholder="(?P<time>\d{1,2}:\d{2}\s*(?:AM|PM)?)"
                                   value="{{ group.custom_regex_time if group and group.custom_regex_time else '' }}"
                                   {% if not group or not group.custom_regex_time_enabled %}disabled{% endif %}>
                        </div>
                    </div>

                    {% if mode == 'edit' %}
                    <div class="form-group">
                        <button type="button" class="btn btn-secondary" onclick="testRegexPatterns()" id="test-regex-btn">
                            Test Patterns
                        </button>
                        <div id="regex-test-results" style="margin-top: 0.75rem;"></div>
                    </div>
                    {% endif %}
                </div>
            </div>
        </div>

        <!-- Form Actions -->
        <div class="form-actions">
            <button type="submit" class="btn btn-primary">
                {% if mode == 'add' %}Add Event Group{% else %}Save Changes{% endif %}
            </button>
            <a href="{{ url_for('event_groups_list') }}" class="btn btn-secondary">Cancel</a>
        </div>
    </form>
</div>

<script>
// Channel groups data
let channelGroups = [];
let allChannelGroups = [];

// Stream profiles data
let streamProfiles = [];
let allStreamProfiles = [];

// Channel profiles data
let channelProfiles = [];

// Initialize on page load
document.addEventListener('DOMContentLoaded', async function() {
    await Promise.all([loadChannelGroups(), loadStreamProfiles(), loadChannelProfiles()]);
    {% if mode == 'edit' and group.channel_group_id %}
    document.getElementById('channel_group_id').value = '{{ group.channel_group_id }}';
    {% endif %}
    {% if mode == 'edit' and group.stream_profile_id %}
    document.getElementById('stream_profile_id').value = '{{ group.stream_profile_id }}';
    {% endif %}
    {% if mode == 'edit' and group.channel_profile_id %}
    document.getElementById('channel_profile_id').value = '{{ group.channel_profile_id }}';
    {% endif %}
});

// League options by sport
const leaguesBySport = {
    'football': [
        { value: 'nfl', label: 'NFL' },
        { value: 'ncaaf', label: 'NCAA Football (FBS)' },
        { value: 'xfl', label: 'XFL' },
        { value: 'cfl', label: 'CFL' }
    ],
    'basketball': [
        { value: 'nba', label: 'NBA' },
        { value: 'wnba', label: 'WNBA' },
        { value: 'ncaam', label: 'NCAA Men\'s Basketball' },
        { value: 'ncaaw', label: 'NCAA Women\'s Basketball' }
    ],
    'baseball': [
        { value: 'mlb', label: 'MLB' }
    ],
    'hockey': [
        { value: 'nhl', label: 'NHL' }
    ],
    'soccer': [
        { value: 'epl', label: 'English Premier League' },
        { value: 'mls', label: 'MLS' },
        { value: 'liga', label: 'La Liga' },
        { value: 'bundesliga', label: 'Bundesliga' },
        { value: 'seriea', label: 'Serie A' },
        { value: 'ligue1', label: 'Ligue 1' },
        { value: 'ucl', label: 'UEFA Champions League' }
    ]
};

function updateLeagueOptions() {
    const sport = document.getElementById('assigned_sport').value;
    const leagueSelect = document.getElementById('assigned_league');

    leagueSelect.innerHTML = '<option value="">Select league...</option>';

    if (sport && leaguesBySport[sport]) {
        leaguesBySport[sport].forEach(league => {
            const option = document.createElement('option');
            option.value = league.value;
            option.textContent = league.label;
            leagueSelect.appendChild(option);
        });
    }
}

async function loadChannelGroups() {
    try {
        const response = await fetch('/api/dispatcharr/channel-groups?exclude_m3u=true');
        const data = await response.json();

        if (response.ok && data.groups) {
            allChannelGroups = data.groups || [];
            channelGroups = [...allChannelGroups];
            renderChannelGroups();
        } else {
            console.error('Failed to load channel groups:', data.error);
            document.getElementById('channel_group_id').innerHTML = '<option value="">(Failed to load groups)</option>';
        }
    } catch (error) {
        console.error('Error loading channel groups:', error);
        document.getElementById('channel_group_id').innerHTML = '<option value="">(Error loading groups)</option>';
    }
}

function renderChannelGroups() {
    const select = document.getElementById('channel_group_id');
    const currentValue = select.value;

    select.innerHTML = '<option value="">&lt;No group assignment&gt;</option>';

    channelGroups.forEach(group => {
        const option = document.createElement('option');
        option.value = group.id;
        option.textContent = group.name;
        select.appendChild(option);
    });

    if (currentValue) {
        select.value = currentValue;
    }
}

function filterChannelGroups() {
    const filter = document.getElementById('group-filter').value.toLowerCase();

    if (!filter) {
        channelGroups = [...allChannelGroups];
    } else {
        channelGroups = allChannelGroups.filter(g =>
            g.name.toLowerCase().includes(filter)
        );
    }

    renderChannelGroups();
}

function toggleCreateGroupForm() {
    const form = document.getElementById('create-group-form');
    form.style.display = form.style.display === 'none' ? 'block' : 'none';
    if (form.style.display === 'block') {
        document.getElementById('new-group-name').focus();
    }
}

async function createGroupInline() {
    const name = document.getElementById('new-group-name').value.trim();
    const statusDiv = document.getElementById('create-group-status');

    if (!name) {
        statusDiv.innerHTML = '<span style="color: var(--danger);">Please enter a group name</span>';
        return;
    }

    statusDiv.innerHTML = '<span style="color: var(--text-muted);">Creating...</span>';

    try {
        const response = await fetch('/api/dispatcharr/channel-groups', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: name })
        });

        const data = await response.json();

        if (data.success) {
            statusDiv.innerHTML = '<span style="color: var(--success);">Created!</span>';
            document.getElementById('new-group-name').value = '';

            // Reload groups and select the new one
            await loadChannelGroups();
            document.getElementById('channel_group_id').value = data.group.id;

            setTimeout(() => {
                toggleCreateGroupForm();
            }, 500);
        } else {
            statusDiv.innerHTML = `<span style="color: var(--danger);">${data.error || 'Failed to create group'}</span>`;
        }
    } catch (error) {
        statusDiv.innerHTML = `<span style="color: var(--danger);">Error: ${error.message}</span>`;
    }
}

function toggleSection(sectionId) {
    const content = document.getElementById(sectionId + '-content');
    const arrow = document.getElementById(sectionId + '-arrow');

    if (content.style.display === 'none') {
        content.style.display = 'block';
        arrow.textContent = '▼';
    } else {
        content.style.display = 'none';
        arrow.textContent = '▶';
    }
}

function toggleRegexField(fieldId) {
    const checkbox = document.getElementById(fieldId + '_enabled');
    const input = document.getElementById(fieldId);

    if (checkbox.checked) {
        input.disabled = false;
        input.classList.remove('disabled-field');
    } else {
        input.disabled = true;
        input.classList.add('disabled-field');
    }
}

// ============================================================================
// Stream Profiles
// ============================================================================

async function loadStreamProfiles() {
    try {
        const response = await fetch('/api/dispatcharr/stream-profiles');
        const data = await response.json();

        if (response.ok && data.profiles) {
            allStreamProfiles = data.profiles || [];
            streamProfiles = [...allStreamProfiles];
            renderStreamProfiles();
        } else {
            console.error('Failed to load stream profiles:', data.error);
            document.getElementById('stream_profile_id').innerHTML = '<option value="">(Failed to load profiles)</option>';
        }
    } catch (error) {
        console.error('Error loading stream profiles:', error);
        document.getElementById('stream_profile_id').innerHTML = '<option value="">(Error loading profiles)</option>';
    }
}

function renderStreamProfiles() {
    const select = document.getElementById('stream_profile_id');
    const currentValue = select.value;

    select.innerHTML = '';

    streamProfiles.forEach(profile => {
        const option = document.createElement('option');
        option.value = profile.id;
        const activeIndicator = profile.is_active ? '' : ' (inactive)';
        option.textContent = profile.name + activeIndicator;
        select.appendChild(option);
    });

    if (currentValue) {
        select.value = currentValue;
    }
}

function filterStreamProfiles() {
    const filter = document.getElementById('profile-filter').value.toLowerCase();

    if (!filter) {
        streamProfiles = [...allStreamProfiles];
    } else {
        streamProfiles = allStreamProfiles.filter(p =>
            p.name.toLowerCase().includes(filter)
        );
    }

    renderStreamProfiles();
}

async function loadChannelProfiles() {
    try {
        const response = await fetch('/api/dispatcharr/channel-profiles');
        const data = await response.json();

        if (response.ok && data.profiles) {
            channelProfiles = data.profiles || [];
            renderChannelProfiles();
        } else {
            console.error('Failed to load channel profiles:', data.error);
            document.getElementById('channel_profile_id').innerHTML = '<option value="">(Failed to load profiles)</option>';
        }
    } catch (error) {
        console.error('Error loading channel profiles:', error);
        document.getElementById('channel_profile_id').innerHTML = '<option value="">(Error loading profiles)</option>';
    }
}

function renderChannelProfiles() {
    const select = document.getElementById('channel_profile_id');
    const currentValue = select.value;

    select.innerHTML = '';

    channelProfiles.forEach(profile => {
        const option = document.createElement('option');
        option.value = profile.id;
        option.textContent = profile.name;
        select.appendChild(option);
    });

    if (currentValue) {
        select.value = currentValue;
    }
}

function filterChannelProfiles() {
    const filter = document.getElementById('channel-profile-filter').value.toLowerCase();
    const select = document.getElementById('channel_profile_id');
    const currentValue = select.value;

    select.innerHTML = '';

    channelProfiles.forEach(profile => {
        if (profile.name.toLowerCase().includes(filter)) {
            const option = document.createElement('option');
            option.value = profile.id;
            option.textContent = profile.name;
            select.appendChild(option);
        }
    });

    if (currentValue && select.querySelector(`option[value="${currentValue}"]`)) {
        select.value = currentValue;
    }
}

{% if mode == 'edit' %}
async function testRegexPatterns() {
    const teamsPattern = document.getElementById('custom_regex_teams').value.trim();
    const datePattern = document.getElementById('custom_regex_date').value.trim();
    const timePattern = document.getElementById('custom_regex_time').value.trim();
    const resultsDiv = document.getElementById('regex-test-results');
    const testBtn = document.getElementById('test-regex-btn');

    if (!teamsPattern) {
        resultsDiv.innerHTML = '<span style="color: var(--warning);">Teams pattern is required.</span>';
        return;
    }

    // Validate that pattern has required named groups
    if (!teamsPattern.includes('(?P<team1>') || !teamsPattern.includes('(?P<team2>')) {
        resultsDiv.innerHTML = '<span style="color: var(--warning);">Pattern must include (?P&lt;team1&gt;...) and (?P&lt;team2&gt;...) groups.</span>';
        return;
    }

    testBtn.disabled = true;
    testBtn.textContent = 'Testing...';
    resultsDiv.innerHTML = '<span style="color: var(--text-muted);">Testing patterns against streams...</span>';

    try {
        const response = await fetch('/api/event-epg/groups/{{ group.id }}/test-regex', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                teams_pattern: teamsPattern,
                date_pattern: datePattern || null,
                time_pattern: timePattern || null
            })
        });

        const data = await response.json();

        if (!response.ok) {
            resultsDiv.innerHTML = `<span style="color: var(--danger);">Error: ${escapeHtml(data.error)}</span>`;
            return;
        }

        let html = '';
        const matched = data.matched || 0;
        const total = data.tested || 0;
        const percentage = total > 0 ? Math.round((matched / total) * 100) : 0;

        html = `<div style="margin-bottom: 0.5rem;">
            <strong>${matched}/${total}</strong> streams matched (${percentage}%)
        </div>`;

        if (data.results && data.results.length > 0) {
            html += '<div class="test-results-list">';
            data.results.forEach(result => {
                const icon = result.matched ? '✓' : '✗';
                const color = result.matched ? 'var(--success)' : 'var(--danger)';
                html += `<div class="test-result-item">
                    <div style="color: ${color}; display: flex; align-items: center; gap: 0.25rem;">
                        <span>${icon}</span>
                        <div class="stream-name-scroll">
                            <code>${escapeHtml(result.stream_name)}</code>
                        </div>
                    </div>`;
                if (result.matched) {
                    html += `<div class="test-result-detail">
                        ${escapeHtml(result.raw_team1)} → ${escapeHtml(result.resolved_team1)}<br>
                        ${escapeHtml(result.raw_team2)} → ${escapeHtml(result.resolved_team2)}`;
                    if (result.game_date || result.game_time) {
                        html += `<br>Date/Time: ${result.game_date || '-'} ${result.game_time || '-'}`;
                    }
                    html += '</div>';
                } else if (result.error) {
                    html += `<div class="test-result-detail" style="color: var(--danger);">${escapeHtml(result.error)}</div>`;
                }
                html += '</div>';
            });
            html += '</div>';
        }

        resultsDiv.innerHTML = html;
    } catch (error) {
        resultsDiv.innerHTML = `<span style="color: var(--danger);">Error: ${escapeHtml(error.message)}</span>`;
    } finally {
        testBtn.disabled = false;
        testBtn.textContent = 'Test Patterns';
    }
}
{% endif %}

function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Form submission
document.getElementById('event-group-form').addEventListener('submit', async function(e) {
    e.preventDefault();

    const formData = new FormData(this);
    const data = {};

    // Checkbox fields that need boolean handling
    const checkboxFields = [
        'skip_builtin_filter',
        'stream_exclude_regex_enabled',
        'custom_regex_teams_enabled',
        'custom_regex_date_enabled',
        'custom_regex_time_enabled',
        'custom_regex_enabled'  // Legacy - keep for backwards compat
    ];

    formData.forEach((value, key) => {
        if (value !== '' && value !== null) {
            // Convert numeric fields
            if (['channel_start', 'channel_group_id', 'stream_profile_id', 'channel_profile_id', 'event_template_id', 'dispatcharr_group_id', 'dispatcharr_account_id'].includes(key)) {
                data[key] = value ? parseInt(value) : null;
            } else if (checkboxFields.includes(key)) {
                data[key] = true;
            } else {
                data[key] = value;
            }
        }
    });

    // Handle unchecked checkboxes - set to false
    checkboxFields.forEach(field => {
        if (!formData.has(field)) {
            data[field] = false;
        }
    });

    {% if mode == 'edit' %}
    const url = '/api/event-epg/groups/{{ group.id }}';
    const method = 'PATCH';
    {% else %}
    const url = '/api/event-epg/groups';
    const method = 'POST';
    {% endif %}

    try {
        const response = await fetch(url, {
            method: method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });

        const result = await response.json();

        if (response.ok) {
            window.location.href = '{{ url_for("event_groups_list") }}';
        } else {
            alert('Error: ' + (result.error || 'Failed to save'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
});
</script>

<style>
.form-container {
    max-width: 900px;
    margin: 0 auto;
    padding: 2rem 0;
}

.page-header {
    margin-bottom: 2rem;
}

.page-header h1 {
    margin: 0 0 0.5rem 0;
    font-size: 2rem;
    color: var(--text-primary);
}

.page-subtitle {
    margin: 0;
    color: var(--text-muted);
    font-size: 1rem;
}

.form-section {
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
}

.form-section h2 {
    margin: 0 0 0.5rem 0;
    font-size: 1.1rem;
    color: var(--text-primary);
}

.section-description {
    color: var(--text-muted);
    font-size: 0.875rem;
    margin: 0 0 1.25rem 0;
}

.group-info-display {
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 1rem;
    margin-bottom: 1.25rem;
}

.form-group {
    margin-bottom: 1.25rem;
}

.form-group:last-child {
    margin-bottom: 0;
}

.form-group label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: 500;
    color: var(--text-secondary);
    font-size: 0.9rem;
}

.required {
    color: var(--danger);
}

.optional {
    color: var(--text-muted);
    font-weight: normal;
}

.form-control {
    width: 100%;
    padding: 0.5rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: 6px;
    font-size: 0.9rem;
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.form-control:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.form-control.mono {
    font-family: monospace;
    font-size: 0.85rem;
}

select.form-control {
    padding-right: 2rem;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2394a3b8' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 0.75rem center;
    background-size: 12px;
}

.form-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
}

.form-help {
    display: block;
    margin-top: 0.25rem;
    font-size: 0.8rem;
    color: var(--text-muted);
}

.form-help code {
    background: var(--bg-tertiary);
    padding: 0.1rem 0.3rem;
    border-radius: 3px;
    font-size: 0.75rem;
}

.checkbox-label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    font-weight: normal;
}

.checkbox-label input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
}

.form-actions {
    display: flex;
    gap: 1rem;
    padding-top: 0.5rem;
}

.regex-builder-section {
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 1rem;
}

.regex-input {
    background: var(--bg-secondary) !important;
    border: 2px solid var(--border) !important;
    padding: 0.6rem 0.75rem !important;
    font-size: 0.9rem;
}

.regex-input:focus {
    border-color: var(--primary) !important;
    outline: none;
    box-shadow: 0 0 0 2px rgba(var(--primary-rgb), 0.2);
}

.regex-input::placeholder {
    color: var(--text-muted);
    opacity: 0.7;
}

/* Collapsible sections */
.collapsible-header {
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.collapsible-header:hover {
    color: var(--primary);
}

.collapse-arrow {
    font-size: 0.8rem;
    transition: transform 0.2s;
}

.collapsible-content {
    margin-top: 1rem;
}

/* Subsections within collapsible */
.subsection {
    padding: 1rem 0;
    border-bottom: 1px solid var(--border);
}

.subsection:last-child {
    border-bottom: none;
    padding-bottom: 0;
}

.subsection:first-child {
    padding-top: 0;
}

.subsection-header {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-primary);
    margin: 0 0 0.5rem 0;
}

/* Regex field with enable checkbox */
.regex-field-group {
    margin-bottom: 0.75rem;
}

.regex-field-header {
    margin-bottom: 0.25rem;
}

.disabled-field {
    opacity: 0.5;
    background: var(--bg-tertiary) !important;
}

.test-results-list {
    font-size: 0.75rem;
    max-height: 250px;
    overflow-y: auto;
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0.5rem;
    background: var(--bg-tertiary);
}

.test-result-item {
    margin-bottom: 0.5rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--border);
}

.test-result-item:last-child {
    margin-bottom: 0;
    padding-bottom: 0;
    border-bottom: none;
}

.stream-name-scroll {
    overflow-x: auto;
    white-space: nowrap;
    flex: 1;
    padding: 2px 0;
}

.stream-name-scroll code {
    font-size: 0.7rem;
}

.test-result-detail {
    margin-left: 1rem;
    margin-top: 0.25rem;
    color: var(--text-muted);
    font-size: 0.7rem;
}

@media (max-width: 768px) {
    .form-row {
        grid-template-columns: 1fr;
    }
}
</style>
{% endblock %}
